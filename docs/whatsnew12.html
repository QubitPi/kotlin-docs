<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-07-05T00:45:43.334452129"><link rel="canonical" href="https://kotlinlang.org/docs/whatsnew12.html" data-react-helmet="true"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>What's new in Kotlin 1.2 | Kotlin Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"table-of-contents","level":0,"title":"Table of contents","anchor":"#table-of-contents"},{"id":"multiplatform-projects-experimental","level":0,"title":"Multiplatform projects (experimental)","anchor":"#multiplatform-projects-experimental"},{"id":"other-language-features","level":0,"title":"Other language features","anchor":"#other-language-features"},{"id":"array-literals-in-annotations","level":1,"title":"Array literals in annotations","anchor":"#array-literals-in-annotations"},{"id":"lateinit-top-level-properties-and-local-variables","level":1,"title":"Lateinit top-level properties and local variables","anchor":"#lateinit-top-level-properties-and-local-variables"},{"id":"check-whether-a-lateinit-var-is-initialized","level":1,"title":"Check whether a lateinit var is initialized","anchor":"#check-whether-a-lateinit-var-is-initialized"},{"id":"inline-functions-with-default-functional-parameters","level":1,"title":"Inline functions with default functional parameters","anchor":"#inline-functions-with-default-functional-parameters"},{"id":"information-from-explicit-casts-is-used-for-type-inference","level":1,"title":"Information from explicit casts is used for type inference","anchor":"#information-from-explicit-casts-is-used-for-type-inference"},{"id":"smart-cast-improvements","level":1,"title":"Smart cast improvements","anchor":"#smart-cast-improvements"},{"id":"support-for-foo-as-a-shorthand-for-this-foo","level":1,"title":"Support for  ::foo as a shorthand for this::foo","anchor":"#support-for-foo-as-a-shorthand-for-this-foo"},{"id":"breaking-change-sound-smart-casts-after-try-blocks","level":1,"title":"Breaking change: sound smart casts after try blocks","anchor":"#breaking-change-sound-smart-casts-after-try-blocks"},{"id":"deprecation-data-classes-overriding-copy","level":1,"title":"Deprecation: data classes overriding copy","anchor":"#deprecation-data-classes-overriding-copy"},{"id":"deprecation-nested-types-in-enum-entries","level":1,"title":"Deprecation: nested types in enum entries","anchor":"#deprecation-nested-types-in-enum-entries"},{"id":"deprecation-single-named-argument-for-vararg","level":1,"title":"Deprecation: single named argument for vararg","anchor":"#deprecation-single-named-argument-for-vararg"},{"id":"deprecation-inner-classes-of-generic-classes-extending-throwable","level":1,"title":"Deprecation: inner classes of generic classes extending Throwable","anchor":"#deprecation-inner-classes-of-generic-classes-extending-throwable"},{"id":"deprecation-mutating-backing-field-of-a-read-only-property","level":1,"title":"Deprecation: mutating backing field of a read-only property","anchor":"#deprecation-mutating-backing-field-of-a-read-only-property"},{"id":"standard-library","level":0,"title":"Standard library","anchor":"#standard-library"},{"id":"kotlin-standard-library-artifacts-and-split-packages","level":1,"title":"Kotlin standard library artifacts and split packages","anchor":"#kotlin-standard-library-artifacts-and-split-packages"},{"id":"windowed-chunked-zipwithnext","level":1,"title":"windowed, chunked, zipWithNext","anchor":"#windowed-chunked-zipwithnext"},{"id":"fill-replaceall-shuffle-shuffled","level":1,"title":"fill, replaceAll, shuffle/shuffled","anchor":"#fill-replaceall-shuffle-shuffled"},{"id":"math-operations-in-kotlin-stdlib","level":1,"title":"Math operations in kotlin-stdlib","anchor":"#math-operations-in-kotlin-stdlib"},{"id":"operators-and-conversions-for-biginteger-and-bigdecimal","level":1,"title":"Operators and conversions for BigInteger and BigDecimal","anchor":"#operators-and-conversions-for-biginteger-and-bigdecimal"},{"id":"floating-point-to-bits-conversions","level":1,"title":"Floating point to bits conversions","anchor":"#floating-point-to-bits-conversions"},{"id":"regex-is-now-serializable","level":1,"title":"Regex is now serializable","anchor":"#regex-is-now-serializable"},{"id":"closeable-use-calls-throwable-addsuppressed-if-available","level":1,"title":"Closeable.use calls Throwable.addSuppressed if available","anchor":"#closeable-use-calls-throwable-addsuppressed-if-available"},{"id":"jvm-backend","level":0,"title":"JVM backend","anchor":"#jvm-backend"},{"id":"constructor-calls-normalization","level":1,"title":"Constructor calls normalization","anchor":"#constructor-calls-normalization"},{"id":"java-default-method-calls","level":1,"title":"Java-default method calls","anchor":"#java-default-method-calls"},{"id":"breaking-change-consistent-behavior-of-x-equals-null-for-platform-types","level":1,"title":"Breaking change: consistent behavior of x.equals(null) for platform types","anchor":"#breaking-change-consistent-behavior-of-x-equals-null-for-platform-types"},{"id":"breaking-change-fix-for-platform-null-escaping-through-an-inlined-extension-receiver","level":1,"title":"Breaking change: fix for platform null escaping through an inlined extension receiver","anchor":"#breaking-change-fix-for-platform-null-escaping-through-an-inlined-extension-receiver"},{"id":"javascript-backend","level":0,"title":"JavaScript backend","anchor":"#javascript-backend"},{"id":"typedarrays-support-enabled-by-default","level":1,"title":"TypedArrays support enabled by default","anchor":"#typedarrays-support-enabled-by-default"},{"id":"tools","level":0,"title":"Tools","anchor":"#tools"},{"id":"warnings-as-errors","level":1,"title":"Warnings as errors","anchor":"#warnings-as-errors"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="https://kotlinlang.org/assets/images/favicon.svg?v2"><link rel="icon" type="image/x-icon" sizes="32x32" href="https://kotlinlang.org/assets/images/favicon.ico?v2"><link rel="icon" type="image/png" sizes="96x96" href="https://kotlinlang.org/assets/images/apple-touch-icon.png?v2"><link rel="icon" type="image/png" sizes="300x300" href="https://kotlinlang.org/assets/images/apple-touch-icon-72x72.png?v2"><link rel="icon" type="image/png" sizes="500x500" href="https://kotlinlang.org/assets/images/apple-touch-icon-114x114.png?v2"><meta name="image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- Open Graph --><meta property="og:title" content="What's new in Kotlin 1.2 | Kotlin"><meta property="og:description" content=""><meta property="og:image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/whatsnew12.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="What's new in Kotlin 1.2 | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://kotlinlang.org/docs/whatsnew12.html#webpage",
    "url": "https://kotlinlang.org/docs/whatsnew12.html",
    "name": "What's new in Kotlin 1.2 | Kotlin",
    "description": "",
    "image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://kotlinlang.org/docs/#website",
    "url": "https://kotlinlang.org/docs/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --><style>a[href="test-page.html"] { visibility: hidden; }</style></head><body data-id="whatsnew12" data-main-title="What's new in Kotlin 1.2" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="What's new in Kotlin///Earlier versions" data-edit-url="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/topics/whatsnew/whatsnew12.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="whatsnew12" id="whatsnew12.md">What's new in Kotlin 1.2</h1><p id="-crrf11_2"><span class="emphasis" id="-crrf11_10">Released: 28 November 2017</span></p><section class="chapter"><h2 id="table-of-contents" data-toc="table-of-contents">Table of contents</h2><ul class="list _bullet" id="-crrf11_11"><li class="list__item" id="-crrf11_12"><p id="-crrf11_17"><a href="#multiplatform-projects-experimental" id="-crrf11_18">Multiplatform projects</a></p></li><li class="list__item" id="-crrf11_13"><p id="-crrf11_19"><a href="#other-language-features" id="-crrf11_20">Other language features</a></p></li><li class="list__item" id="-crrf11_14"><p id="-crrf11_21"><a href="#standard-library" id="-crrf11_22">Standard library</a></p></li><li class="list__item" id="-crrf11_15"><p id="-crrf11_23"><a href="#jvm-backend" id="-crrf11_24">JVM backend</a></p></li><li class="list__item" id="-crrf11_16"><p id="-crrf11_25"><a href="#javascript-backend" id="-crrf11_26">JavaScript backend</a></p></li></ul></section><section class="chapter"><h2 id="multiplatform-projects-experimental" data-toc="multiplatform-projects-experimental">Multiplatform projects (experimental)</h2><p id="-crrf11_27">Multiplatform projects are a new <span class="control" id="-crrf11_36">experimental</span> feature in Kotlin 1.2, allowing you to reuse code between target platforms supported by Kotlin &ndash; JVM, JavaScript, and (in the future) Native. In a multiplatform project, you have three kinds of modules:</p><ul class="list _bullet" id="-crrf11_28"><li class="list__item" id="-crrf11_37"><p id="-crrf11_40">A <span class="emphasis" id="-crrf11_41">common</span> module contains code that is not specific to any platform, as well as declarations without implementation of platform-dependent APIs.</p></li><li class="list__item" id="-crrf11_38"><p id="-crrf11_42">A <span class="emphasis" id="-crrf11_43">platform</span> module contains implementations of platform-dependent declarations in the common module for a specific platform, as well as other platform-dependent code.</p></li><li class="list__item" id="-crrf11_39"><p id="-crrf11_44">A regular module targets a specific platform and can either be a dependency of platform modules or depend on platform modules.</p></li></ul><p id="-crrf11_29">When you compile a multiplatform project for a specific platform, the code for both the common and platform-specific parts is generated.</p><p id="-crrf11_30">A key feature of the multiplatform project support is the possibility to express dependencies of common code on platform-specific parts through <span class="emphasis" id="-crrf11_45">expected</span> and <span class="emphasis" id="-crrf11_46">actual</span> declarations. An <span class="emphasis" id="-crrf11_47">expected</span> declaration specifies an API (class, interface, annotation, top-level declaration etc.). An <span class="emphasis" id="-crrf11_48">actual</span> declaration is either a platform-dependent implementation of the API or a type alias referring to an existing implementation of the API in an external library. Here's an example:</p><p id="-crrf11_31">In the common code:</p><div class="code-block" data-lang="kotlin">
// expected platform-specific API:
expect fun hello(world: String): String

fun greet() {
    // usage of the expected API:
    val greeting = hello(&quot;multiplatform world&quot;)
    println(greeting)
}

expect class URL(spec: String) {
    open fun getHost(): String
    open fun getPath(): String
}
</div><p id="-crrf11_33">In the JVM platform code:</p><div class="code-block" data-lang="kotlin">
actual fun hello(world: String): String =
    &quot;Hello, $world, on the JVM platform!&quot;

// using existing platform-specific implementation:
actual typealias URL = java.net.URL
</div><p id="-crrf11_35">See the <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/get-started.html" id="-crrf11_49" data-external="true" rel="noopener noreferrer" target="_blank">multiplatform programming documentation</a> for details and steps to build a multiplatform project.</p></section><section class="chapter"><h2 id="other-language-features" data-toc="other-language-features">Other language features</h2><section class="chapter"><h3 id="array-literals-in-annotations" data-toc="array-literals-in-annotations">Array literals in annotations</h3><p id="-crrf11_63">Starting with Kotlin 1.2, array arguments for annotations can be passed with the new array literal syntax instead of the <code class="code" id="-crrf11_66">arrayOf</code> function:</p><div class="code-block" data-lang="kotlin">
@CacheConfig(cacheNames = [&quot;books&quot;, &quot;default&quot;])
public class BookRepositoryImpl {
    // ...
}
</div><p id="-crrf11_65">The array literal syntax is constrained to annotation arguments.</p></section><section class="chapter"><h3 id="lateinit-top-level-properties-and-local-variables" data-toc="lateinit-top-level-properties-and-local-variables">Lateinit top-level properties and local variables</h3><p id="-crrf11_67">The <code class="code" id="-crrf11_69">lateinit</code> modifier can now be used on top-level properties and local variables. The latter can be used, for example, when a lambda passed as a constructor argument to one object refers to another object which has to be defined later:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
class Node&lt;T&gt;(val value: T, val next: () -&gt; Node&lt;T&gt;)

fun main(args: Array&lt;String&gt;) {
    // A cycle of three nodes:
    lateinit var third: Node&lt;Int&gt;

    val second = Node(2, next = { third })
    val first = Node(1, next = { second })

    third = Node(3, next = { first })

    val nodes = generateSequence(first) { it.next() }
    println(&quot;Values in the cycle: ${nodes.take(7).joinToString { it.value.toString() }}, ...&quot;)
}
</div></section><section class="chapter"><h3 id="check-whether-a-lateinit-var-is-initialized" data-toc="check-whether-a-lateinit-var-is-initialized">Check whether a lateinit var is initialized</h3><p id="-crrf11_70">You can now check whether a lateinit var has been initialized using <code class="code" id="-crrf11_72">isInitialized</code> on the property reference:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
class Foo {
    lateinit var lateinitVar: String

    fun initializationLogic() {
//sampleStart
        println(&quot;isInitialized before assignment: &quot; + this::lateinitVar.isInitialized)
        lateinitVar = &quot;value&quot;
        println(&quot;isInitialized after assignment: &quot; + this::lateinitVar.isInitialized)
//sampleEnd
    }
}

fun main(args: Array&lt;String&gt;) {
	Foo().initializationLogic()
}
</div></section><section class="chapter"><h3 id="inline-functions-with-default-functional-parameters" data-toc="inline-functions-with-default-functional-parameters">Inline functions with default functional parameters</h3><p id="-crrf11_73">Inline functions are now allowed to have default values for their inlined functional parameters:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
//sampleStart
inline fun &lt;E&gt; Iterable&lt;E&gt;.strings(transform: (E) -&gt; String = { it.toString() }) =
    map { transform(it) }

val defaultStrings = listOf(1, 2, 3).strings()
val customStrings = listOf(1, 2, 3).strings { &quot;($it)&quot; } 
//sampleEnd

fun main(args: Array&lt;String&gt;) {
    println(&quot;defaultStrings = $defaultStrings&quot;)
    println(&quot;customStrings = $customStrings&quot;)
}
</div></section><section class="chapter"><h3 id="information-from-explicit-casts-is-used-for-type-inference" data-toc="information-from-explicit-casts-is-used-for-type-inference">Information from explicit casts is used for type inference</h3><p id="-crrf11_75">The Kotlin compiler can now use information from type casts in type inference. If you're calling a generic method that returns a type parameter <code class="code" id="-crrf11_78">T</code> and casting the return value to a specific type <code class="code" id="-crrf11_79">Foo</code>, the compiler now understands that <code class="code" id="-crrf11_80">T</code> for this call needs to be bound to the type <code class="code" id="-crrf11_81">Foo</code>.</p><p id="-crrf11_76">This is particularly important for Android developers, since the compiler can now correctly analyze generic <code class="code" id="-crrf11_82">findViewById</code> calls in Android API level 26:</p><div class="code-block" data-lang="kotlin">
val button = findViewById(R.id.button) as Button
</div></section><section class="chapter"><h3 id="smart-cast-improvements" data-toc="smart-cast-improvements">Smart cast improvements</h3><p id="-crrf11_83">When a variable is assigned from a safe call expression and checked for null, the smart cast is now applied to the safe call receiver as well:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun countFirst(s: Any): Int {
//sampleStart
    val firstChar = (s as? CharSequence)?.firstOrNull()
    if (firstChar != null)
    return s.count { it == firstChar } // s: Any is smart cast to CharSequence

    val firstItem = (s as? Iterable&lt;*&gt;)?.firstOrNull()
    if (firstItem != null)
    return s.count { it == firstItem } // s: Any is smart cast to Iterable&lt;*&gt;
//sampleEnd
    return -1
}

fun main(args: Array&lt;String&gt;) {
  val string = &quot;abacaba&quot;
  val countInString = countFirst(string)
  println(&quot;called on \&quot;$string\&quot;: $countInString&quot;)

  val list = listOf(1, 2, 3, 1, 2)
  val countInList = countFirst(list)
  println(&quot;called on $list: $countInList&quot;)
}
</div><p id="-crrf11_85">Also, smart casts in a lambda are now allowed for local variables that are only modified before the lambda:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main(args: Array&lt;String&gt;) {
//sampleStart
    val flag = args.size == 0
    var x: String? = null
    if (flag) x = &quot;Yahoo!&quot;

    run {
        if (x != null) {
            println(x.length) // x is smart cast to String
        }
    }
//sampleEnd
}
</div></section><section class="chapter"><h3 id="support-for-foo-as-a-shorthand-for-this-foo" data-toc="support-for-foo-as-a-shorthand-for-this-foo">Support for  ::foo as a shorthand for this::foo</h3><p id="-crrf11_87">A bound callable reference to a member of <code class="code" id="-crrf11_88">this</code> can now be written without explicit receiver, <code class="code" id="-crrf11_89">::foo</code> instead of <code class="code" id="-crrf11_90">this::foo</code>. This also makes callable references more convenient to use in lambdas where you refer to a member of the outer receiver.</p></section><section class="chapter"><h3 id="breaking-change-sound-smart-casts-after-try-blocks" data-toc="breaking-change-sound-smart-casts-after-try-blocks">Breaking change: sound smart casts after try blocks</h3><p id="-crrf11_91">Earlier, Kotlin used assignments made inside a <code class="code" id="-crrf11_93">try</code> block for smart casts after the block, which could break type- and null-safety and lead to runtime failures. This release fixes this issue, making the smart casts more strict, but breaking some code that relied on such smart casts.</p><p id="-crrf11_92">To switch to the old smart casts behavior, pass the fallback flag <code class="code" id="-crrf11_94">-Xlegacy-smart-cast-after-try</code> as the compiler argument. It will become deprecated in Kotlin 1.3.</p></section><section class="chapter"><h3 id="deprecation-data-classes-overriding-copy" data-toc="deprecation-data-classes-overriding-copy">Deprecation: data classes overriding copy</h3><p id="-crrf11_95">When a data class derived from a type that already had the <code class="code" id="-crrf11_97">copy</code> function with the same signature, the <code class="code" id="-crrf11_98">copy</code> implementation generated for the data class used the defaults from the supertype, leading to counter-intuitive behavior, or failed at runtime if there were no default parameters in the supertype.</p><p id="-crrf11_96">Inheritance that leads to a <code class="code" id="-crrf11_99">copy</code> conflict has become deprecated with a warning in Kotlin 1.2 and will be an error in Kotlin 1.3.</p></section><section class="chapter"><h3 id="deprecation-nested-types-in-enum-entries" data-toc="deprecation-nested-types-in-enum-entries">Deprecation: nested types in enum entries</h3><p id="-crrf11_100">Inside enum entries, defining a nested type that is not an <code class="code" id="-crrf11_101">inner class</code> has been deprecated due to issues in the initialization logic. This causes a warning in Kotlin 1.2 and will become an error in Kotlin 1.3.</p></section><section class="chapter"><h3 id="deprecation-single-named-argument-for-vararg" data-toc="deprecation-single-named-argument-for-vararg">Deprecation: single named argument for vararg</h3><p id="-crrf11_102">For consistency with array literals in annotations, passing a single item for a vararg parameter in the named form (<code class="code" id="-crrf11_105">foo(items = i)</code>) has been deprecated. Please use the spread operator with the corresponding array factory functions:</p><div class="code-block" data-lang="kotlin">
foo(items = *arrayOf(1))
</div><p id="-crrf11_104">There is an optimization that removes redundant arrays creation in such cases, which prevents performance degradation. The single-argument form produces warnings in Kotlin 1.2 and is to be dropped in Kotlin 1.3.</p></section><section class="chapter"><h3 id="deprecation-inner-classes-of-generic-classes-extending-throwable" data-toc="deprecation-inner-classes-of-generic-classes-extending-throwable">Deprecation: inner classes of generic classes extending Throwable</h3><p id="-crrf11_106">Inner classes of generic types that inherit from <code class="code" id="-crrf11_107">Throwable</code> could violate type-safety in a throw-catch scenario and thus have been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</p></section><section class="chapter"><h3 id="deprecation-mutating-backing-field-of-a-read-only-property" data-toc="deprecation-mutating-backing-field-of-a-read-only-property">Deprecation: mutating backing field of a read-only property</h3><p id="-crrf11_108">Mutating the backing field of a read-only property by assigning <code class="code" id="-crrf11_109">field = ...</code> in the custom getter has been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</p></section></section><section class="chapter"><h2 id="standard-library" data-toc="standard-library">Standard library</h2><section class="chapter"><h3 id="kotlin-standard-library-artifacts-and-split-packages" data-toc="kotlin-standard-library-artifacts-and-split-packages">Kotlin standard library artifacts and split packages</h3><p id="-crrf11_118">The Kotlin standard library is now fully compatible with the Java 9 module system, which forbids split packages (multiple jar files declaring classes in the same package). In order to support that, new artifacts <code class="code" id="-crrf11_121">kotlin-stdlib-jdk7</code> and <code class="code" id="-crrf11_122">kotlin-stdlib-jdk8</code> are introduced, which replace the old <code class="code" id="-crrf11_123">kotlin-stdlib-jre7</code> and <code class="code" id="-crrf11_124">kotlin-stdlib-jre8</code>.</p><p id="-crrf11_119">The declarations in the new artifacts are visible under the same package names from the Kotlin point of view, but have different package names for Java. Therefore, switching to the new artifacts will not require any changes to your source code.</p><p id="-crrf11_120">Another change made to ensure compatibility with the new module system is removing the deprecated declarations in the <code class="code" id="-crrf11_125">kotlin.reflect</code> package from the <code class="code" id="-crrf11_126">kotlin-reflect</code> library. If you were using them, you need to switch to using the declarations in the <code class="code" id="-crrf11_127">kotlin.reflect.full</code> package, which is supported since Kotlin 1.1.</p></section><section class="chapter"><h3 id="windowed-chunked-zipwithnext" data-toc="windowed-chunked-zipwithnext">windowed, chunked, zipWithNext</h3><p id="-crrf11_128">New extensions for <code class="code" id="-crrf11_130">Iterable&lt;T&gt;</code>, <code class="code" id="-crrf11_131">Sequence&lt;T&gt;</code>, and <code class="code" id="-crrf11_132">CharSequence</code> cover such use cases as buffering or batch processing (<code class="code" id="-crrf11_133">chunked</code>), sliding window and computing sliding average (<code class="code" id="-crrf11_134">windowed</code>) , and processing pairs of subsequent items (<code class="code" id="-crrf11_135">zipWithNext</code>):</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main(args: Array&lt;String&gt;) {
//sampleStart
    val items = (1..9).map { it * it }

    val chunkedIntoLists = items.chunked(4)
    val points3d = items.chunked(3) { (x, y, z) -&gt; Triple(x, y, z) }
    val windowed = items.windowed(4)
    val slidingAverage = items.windowed(4) { it.average() }
    val pairwiseDifferences = items.zipWithNext { a, b -&gt; b - a }
//sampleEnd

    println(&quot;items: $items\n&quot;)

    println(&quot;chunked into lists: $chunkedIntoLists&quot;)
    println(&quot;3D points: $points3d&quot;)
    println(&quot;windowed by 4: $windowed&quot;)
    println(&quot;sliding average by 4: $slidingAverage&quot;)
    println(&quot;pairwise differences: $pairwiseDifferences&quot;)
}
</div></section><section class="chapter"><h3 id="fill-replaceall-shuffle-shuffled" data-toc="fill-replaceall-shuffle-shuffled">fill, replaceAll, shuffle/shuffled</h3><p id="-crrf11_136">A set of extension functions was added for manipulating lists: <code class="code" id="-crrf11_138">fill</code>, <code class="code" id="-crrf11_139">replaceAll</code> and <code class="code" id="-crrf11_140">shuffle</code> for <code class="code" id="-crrf11_141">MutableList</code>, and <code class="code" id="-crrf11_142">shuffled</code> for read-only <code class="code" id="-crrf11_143">List</code>:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.3">
fun main(args: Array&lt;String&gt;) {
//sampleStart
    val items = (1..5).toMutableList()
    
    items.shuffle()
    println(&quot;Shuffled items: $items&quot;)
    
    items.replaceAll { it * 2 }
    println(&quot;Items doubled: $items&quot;)
    
    items.fill(5)
    println(&quot;Items filled with 5: $items&quot;)
//sampleEnd
}
</div></section><section class="chapter"><h3 id="math-operations-in-kotlin-stdlib" data-toc="math-operations-in-kotlin-stdlib">Math operations in kotlin-stdlib</h3><p id="-crrf11_144">Satisfying the longstanding request, Kotlin 1.2 adds the <code class="code" id="-crrf11_147">kotlin.math</code> API for math operations that is common for JVM and JS and contains the following:</p><ul class="list _bullet" id="-crrf11_145"><li class="list__item" id="-crrf11_148"><p id="-crrf11_157">Constants: <code class="code" id="-crrf11_158">PI</code> and <code class="code" id="-crrf11_159">E</code></p></li><li class="list__item" id="-crrf11_149"><p id="-crrf11_160">Trigonometric: <code class="code" id="-crrf11_161">cos</code>, <code class="code" id="-crrf11_162">sin</code>, <code class="code" id="-crrf11_163">tan</code> and inverse of them: <code class="code" id="-crrf11_164">acos</code>, <code class="code" id="-crrf11_165">asin</code>, <code class="code" id="-crrf11_166">atan</code>, <code class="code" id="-crrf11_167">atan2</code></p></li><li class="list__item" id="-crrf11_150"><p id="-crrf11_168">Hyperbolic: <code class="code" id="-crrf11_169">cosh</code>, <code class="code" id="-crrf11_170">sinh</code>, <code class="code" id="-crrf11_171">tanh</code> and their inverse: <code class="code" id="-crrf11_172">acosh</code>, <code class="code" id="-crrf11_173">asinh</code>, <code class="code" id="-crrf11_174">atanh</code></p></li><li class="list__item" id="-crrf11_151"><p id="-crrf11_175">Exponentation: <code class="code" id="-crrf11_176">pow</code> (an extension function), <code class="code" id="-crrf11_177">sqrt</code>, <code class="code" id="-crrf11_178">hypot</code>, <code class="code" id="-crrf11_179">exp</code>, <code class="code" id="-crrf11_180">expm1</code></p></li><li class="list__item" id="-crrf11_152"><p id="-crrf11_181">Logarithms: <code class="code" id="-crrf11_182">log</code>, <code class="code" id="-crrf11_183">log2</code>, <code class="code" id="-crrf11_184">log10</code>, <code class="code" id="-crrf11_185">ln</code>, <code class="code" id="-crrf11_186">ln1p</code></p></li><li class="list__item" id="-crrf11_153"><p id="-crrf11_187">Rounding:</p><ul class="list _bullet" id="-crrf11_188"><li class="list__item" id="-crrf11_189"><p id="-crrf11_191"><code class="code" id="-crrf11_192">ceil</code>, <code class="code" id="-crrf11_193">floor</code>, <code class="code" id="-crrf11_194">truncate</code>, <code class="code" id="-crrf11_195">round</code> (half to even) functions</p></li><li class="list__item" id="-crrf11_190"><p id="-crrf11_196"><code class="code" id="-crrf11_197">roundToInt</code>, <code class="code" id="-crrf11_198">roundToLong</code> (half to integer) extension functions</p></li></ul></li><li class="list__item" id="-crrf11_154"><p id="-crrf11_199">Sign and absolute value:</p><ul class="list _bullet" id="-crrf11_200"><li class="list__item" id="-crrf11_201"><p id="-crrf11_204"><code class="code" id="-crrf11_205">abs</code> and <code class="code" id="-crrf11_206">sign</code> functions</p></li><li class="list__item" id="-crrf11_202"><p id="-crrf11_207"><code class="code" id="-crrf11_208">absoluteValue</code> and <code class="code" id="-crrf11_209">sign</code> extension properties</p></li><li class="list__item" id="-crrf11_203"><p id="-crrf11_210"><code class="code" id="-crrf11_211">withSign</code> extension function</p></li></ul></li><li class="list__item" id="-crrf11_155"><p id="-crrf11_212"><code class="code" id="-crrf11_213">max</code> and <code class="code" id="-crrf11_214">min</code> of two values</p></li><li class="list__item" id="-crrf11_156"><p id="-crrf11_215">Binary representation:</p><ul class="list _bullet" id="-crrf11_216"><li class="list__item" id="-crrf11_217"><p id="-crrf11_220"><code class="code" id="-crrf11_221">ulp</code> extension property</p></li><li class="list__item" id="-crrf11_218"><p id="-crrf11_222"><code class="code" id="-crrf11_223">nextUp</code>, <code class="code" id="-crrf11_224">nextDown</code>, <code class="code" id="-crrf11_225">nextTowards</code> extension functions</p></li><li class="list__item" id="-crrf11_219"><p id="-crrf11_226"><code class="code" id="-crrf11_227">toBits</code>, <code class="code" id="-crrf11_228">toRawBits</code>, <code class="code" id="-crrf11_229">Double.fromBits</code> (these are in the <code class="code" id="-crrf11_230">kotlin</code> package)</p></li></ul></li></ul><p id="-crrf11_146">The same set of functions (but without constants) is also available for <code class="code" id="-crrf11_231">Float</code> arguments.</p></section><section class="chapter"><h3 id="operators-and-conversions-for-biginteger-and-bigdecimal" data-toc="operators-and-conversions-for-biginteger-and-bigdecimal">Operators and conversions for BigInteger and BigDecimal</h3><p id="-crrf11_232">Kotlin 1.2 introduces a set of functions for operating with <code class="code" id="-crrf11_234">BigInteger</code> and <code class="code" id="-crrf11_235">BigDecimal</code> and creating them from other numeric types. These are:</p><ul class="list _bullet" id="-crrf11_233"><li class="list__item" id="-crrf11_236"><p id="-crrf11_239"><code class="code" id="-crrf11_240">toBigInteger</code> for <code class="code" id="-crrf11_241">Int</code> and <code class="code" id="-crrf11_242">Long</code></p></li><li class="list__item" id="-crrf11_237"><p id="-crrf11_243"><code class="code" id="-crrf11_244">toBigDecimal</code> for <code class="code" id="-crrf11_245">Int</code>, <code class="code" id="-crrf11_246">Long</code>, <code class="code" id="-crrf11_247">Float</code>, <code class="code" id="-crrf11_248">Double</code>, and <code class="code" id="-crrf11_249">BigInteger</code></p></li><li class="list__item" id="-crrf11_238"><p id="-crrf11_250">Arithmetic and bitwise operator functions:</p><ul class="list _bullet" id="-crrf11_251"><li class="list__item" id="-crrf11_252"><p id="-crrf11_254">Binary operators <code class="code" id="-crrf11_255">+</code>, <code class="code" id="-crrf11_256">-</code>, <code class="code" id="-crrf11_257">*</code>, <code class="code" id="-crrf11_258">/</code>, <code class="code" id="-crrf11_259">%</code> and infix functions <code class="code" id="-crrf11_260">and</code>, <code class="code" id="-crrf11_261">or</code>, <code class="code" id="-crrf11_262">xor</code>, <code class="code" id="-crrf11_263">shl</code>, <code class="code" id="-crrf11_264">shr</code></p></li><li class="list__item" id="-crrf11_253"><p id="-crrf11_265">Unary operators <code class="code" id="-crrf11_266">-</code>, <code class="code" id="-crrf11_267">++</code>, <code class="code" id="-crrf11_268">--</code>, and a function <code class="code" id="-crrf11_269">inv</code></p></li></ul></li></ul></section><section class="chapter"><h3 id="floating-point-to-bits-conversions" data-toc="floating-point-to-bits-conversions">Floating point to bits conversions</h3><p id="-crrf11_270">New functions were added for converting <code class="code" id="-crrf11_272">Double</code> and <code class="code" id="-crrf11_273">Float</code> to and from their bit representations:</p><ul class="list _bullet" id="-crrf11_271"><li class="list__item" id="-crrf11_274"><p id="-crrf11_276"><code class="code" id="-crrf11_277">toBits</code> and <code class="code" id="-crrf11_278">toRawBits</code> returning <code class="code" id="-crrf11_279">Long</code> for <code class="code" id="-crrf11_280">Double</code> and <code class="code" id="-crrf11_281">Int</code> for <code class="code" id="-crrf11_282">Float</code></p></li><li class="list__item" id="-crrf11_275"><p id="-crrf11_283"><code class="code" id="-crrf11_284">Double.fromBits</code> and <code class="code" id="-crrf11_285">Float.fromBits</code> for creating floating point numbers from the bit representation</p></li></ul></section><section class="chapter"><h3 id="regex-is-now-serializable" data-toc="regex-is-now-serializable">Regex is now serializable</h3><p id="-crrf11_286">The <code class="code" id="-crrf11_287">kotlin.text.Regex</code> class has become <code class="code" id="-crrf11_288">Serializable</code> and can now be used in serializable hierarchies.</p></section><section class="chapter"><h3 id="closeable-use-calls-throwable-addsuppressed-if-available" data-toc="closeable-use-calls-throwable-addsuppressed-if-available">Closeable.use calls Throwable.addSuppressed if available</h3><p id="-crrf11_289">The <code class="code" id="-crrf11_291">Closeable.use</code> function calls <code class="code" id="-crrf11_292">Throwable.addSuppressed</code> when an exception is thrown during closing the resource after some other exception.</p><p id="-crrf11_290">To enable this behavior you need to have <code class="code" id="-crrf11_293">kotlin-stdlib-jdk7</code> in your dependencies.</p></section></section><section class="chapter"><h2 id="jvm-backend" data-toc="jvm-backend">JVM backend</h2><section class="chapter"><h3 id="constructor-calls-normalization" data-toc="constructor-calls-normalization">Constructor calls normalization</h3><p id="-crrf11_298">Ever since version 1.0, Kotlin supported expressions with complex control flow, such as try-catch expressions and inline function calls. Such code is valid according to the Java Virtual Machine specification. Unfortunately, some bytecode processing tools do not handle such code quite well when such expressions are present in the arguments of constructor calls.</p><p id="-crrf11_299">To mitigate this problem for the users of such bytecode processing tools, we've added a command-line compiler option (<code class="code" id="-crrf11_302">-Xnormalize-constructor-calls=MODE</code>) that tells the compiler to generate more Java-like bytecode for such constructs. Here <code class="code" id="-crrf11_303">MODE</code> is one of:</p><ul class="list _bullet" id="-crrf11_300"><li class="list__item" id="-crrf11_304"><p id="-crrf11_307"><code class="code" id="-crrf11_308">disable</code> (default) &ndash; generate bytecode in the same way as in Kotlin 1.0 and 1.1.</p></li><li class="list__item" id="-crrf11_305"><p id="-crrf11_309"><code class="code" id="-crrf11_310">enable</code> &ndash; generate Java-like bytecode for constructor calls. This can change the order in which the classes are loaded and initialized.</p></li><li class="list__item" id="-crrf11_306"><p id="-crrf11_311"><code class="code" id="-crrf11_312">preserve-class-initialization</code> &ndash; generate Java-like bytecode for constructor calls, ensuring that the class initialization order is preserved. This can affect overall performance of your application; use it only if you have some complex state shared between multiple classes and updated on class initialization.</p></li></ul><p id="-crrf11_301">The &quot;manual&quot; workaround is to store the values of sub-expressions with control flow in variables, instead of evaluating them directly inside the call arguments. It's similar to <code class="code" id="-crrf11_313">-Xnormalize-constructor-calls=enable</code>.</p></section><section class="chapter"><h3 id="java-default-method-calls" data-toc="java-default-method-calls">Java-default method calls</h3><p id="-crrf11_314">Before Kotlin 1.2, interface members overriding Java-default methods while targeting JVM 1.6 produced a warning on super calls: <code class="code" id="-crrf11_315">Super calls to Java default methods are deprecated in JVM target 1.6. Recompile with '-jvm-target 1.8'</code>. In Kotlin 1.2, there's an <span class="control" id="-crrf11_316">error</span> instead, thus requiring any such code to be compiled with JVM target 1.8.</p></section><section class="chapter"><h3 id="breaking-change-consistent-behavior-of-x-equals-null-for-platform-types" data-toc="breaking-change-consistent-behavior-of-x-equals-null-for-platform-types">Breaking change: consistent behavior of x.equals(null) for platform types</h3><p id="-crrf11_317">Calling <code class="code" id="-crrf11_319">x.equals(null)</code> on a platform type that is mapped to a Java primitive (<code class="code" id="-crrf11_320">Int!</code>, <code class="code" id="-crrf11_321">Boolean!</code>, <code class="code" id="-crrf11_322">Short</code>!, <code class="code" id="-crrf11_323">Long!</code>, <code class="code" id="-crrf11_324">Float!</code>, <code class="code" id="-crrf11_325">Double!</code>, <code class="code" id="-crrf11_326">Char!</code>) incorrectly returned <code class="code" id="-crrf11_327">true</code> when <code class="code" id="-crrf11_328">x</code> was null. Starting with Kotlin 1.2, calling <code class="code" id="-crrf11_329">x.equals(...)</code> on a null value of a platform type <span class="control" id="-crrf11_330">throws an NPE</span> (but <code class="code" id="-crrf11_331">x == ...</code> does not).</p><p id="-crrf11_318">To return to the pre-1.2 behavior, pass the flag <code class="code" id="-crrf11_332">-Xno-exception-on-explicit-equals-for-boxed-null</code> to the compiler.</p></section><section class="chapter"><h3 id="breaking-change-fix-for-platform-null-escaping-through-an-inlined-extension-receiver" data-toc="breaking-change-fix-for-platform-null-escaping-through-an-inlined-extension-receiver">Breaking change: fix for platform null escaping through an inlined extension receiver</h3><p id="-crrf11_333">Inline extension functions that were called on a null value of a platform type did not check the receiver for null and would thus allow null to escape into the other code. Kotlin 1.2 forces this check at the call sites, throwing an exception if the receiver is null.</p><p id="-crrf11_334">To switch to the old behavior, pass the fallback flag <code class="code" id="-crrf11_335">-Xno-receiver-assertions</code> to the compiler.</p></section></section><section class="chapter"><h2 id="javascript-backend" data-toc="javascript-backend">JavaScript backend</h2><section class="chapter"><h3 id="typedarrays-support-enabled-by-default" data-toc="typedarrays-support-enabled-by-default">TypedArrays support enabled by default</h3><p id="-crrf11_337">The JS typed arrays support that translates Kotlin primitive arrays, such as <code class="code" id="-crrf11_338">IntArray</code>, <code class="code" id="-crrf11_339">DoubleArray</code>, into <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays" id="-crrf11_340" data-external="true" rel="noopener noreferrer" target="_blank">JavaScript typed arrays</a>, that was previously an opt-in feature, has been enabled by default.</p></section></section><section class="chapter"><h2 id="tools" data-toc="tools">Tools</h2><section class="chapter"><h3 id="warnings-as-errors" data-toc="warnings-as-errors">Warnings as errors</h3><p id="-crrf11_342">The compiler now provides an option to treat all warnings as errors. Use <code class="code" id="-crrf11_344">-Werror</code> on the command line, or the following Gradle snippet:</p><div class="code-block" data-lang="groovy">
compileKotlin {
    kotlinOptions.allWarningsAsErrors = true
}
</div></section></section><div class="last-modified">05 July 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="whatsnew13.html" class="navigation-links__prev">What's new in Kotlin 1.3</a><a href="whatsnew11.html" class="navigation-links__next">What's new in Kotlin 1.1</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>