<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-06-26T02:59:07.567390262"><link rel="canonical" href="https://kotlinlang.org/docs/whatsnew14.html" data-react-helmet="true"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>What's new in Kotlin 1.4.0 | Kotlin Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"language-features-and-improvements","level":0,"title":"Language features and improvements","anchor":"#language-features-and-improvements"},{"id":"sam-conversions-for-kotlin-interfaces","level":1,"title":"SAM conversions for Kotlin interfaces","anchor":"#sam-conversions-for-kotlin-interfaces"},{"id":"explicit-api-mode-for-library-authors","level":1,"title":"Explicit API mode for library authors","anchor":"#explicit-api-mode-for-library-authors"},{"id":"mixing-named-and-positional-arguments","level":1,"title":"Mixing named and positional arguments","anchor":"#mixing-named-and-positional-arguments"},{"id":"trailing-comma","level":1,"title":"Trailing comma","anchor":"#trailing-comma"},{"id":"callable-reference-improvements","level":1,"title":"Callable reference improvements","anchor":"#callable-reference-improvements"},{"id":"using-break-and-continue-inside-when-expressions-included-in-loops","level":1,"title":"Using break and continue inside when expressions included in loops","anchor":"#using-break-and-continue-inside-when-expressions-included-in-loops"},{"id":"new-tools-in-the-ide","level":0,"title":"New tools in the IDE","anchor":"#new-tools-in-the-ide"},{"id":"new-flexible-project-wizard","level":1,"title":"New flexible Project Wizard","anchor":"#new-flexible-project-wizard"},{"id":"coroutine-debugger","level":1,"title":"Coroutine Debugger","anchor":"#coroutine-debugger"},{"id":"new-compiler","level":0,"title":"New compiler","anchor":"#new-compiler"},{"id":"new-more-powerful-type-inference-algorithm","level":1,"title":"New more powerful type inference algorithm","anchor":"#new-more-powerful-type-inference-algorithm"},{"id":"unified-backends-and-extensibility","level":1,"title":"Unified backends and extensibility","anchor":"#unified-backends-and-extensibility"},{"id":"kotlin-jvm","level":0,"title":"Kotlin/JVM","anchor":"#kotlin-jvm"},{"id":"new-jvm-ir-backend","level":1,"title":"New JVM IR backend","anchor":"#new-jvm-ir-backend"},{"id":"new-modes-for-generating-default-methods","level":1,"title":"New modes for generating default methods","anchor":"#new-modes-for-generating-default-methods"},{"id":"unified-exception-type-for-null-checks","level":1,"title":"Unified exception type for null checks","anchor":"#unified-exception-type-for-null-checks"},{"id":"type-annotations-in-the-jvm-bytecode","level":1,"title":"Type annotations in the JVM bytecode","anchor":"#type-annotations-in-the-jvm-bytecode"},{"id":"kotlin-js","level":0,"title":"Kotlin/JS","anchor":"#kotlin-js"},{"id":"new-gradle-dsl","level":1,"title":"New Gradle DSL","anchor":"#new-gradle-dsl"},{"id":"new-js-ir-backend","level":1,"title":"New JS IR backend","anchor":"#new-js-ir-backend"},{"id":"kotlin-native","level":0,"title":"Kotlin/Native","anchor":"#kotlin-native"},{"id":"support-for-kotlin-s-suspending-functions-in-swift-and-objective-c","level":1,"title":"Support for Kotlin\u0027s suspending functions in Swift and Objective-C","anchor":"#support-for-kotlin-s-suspending-functions-in-swift-and-objective-c"},{"id":"objective-c-generics-support-by-default","level":1,"title":"Objective-C generics support by default","anchor":"#objective-c-generics-support-by-default"},{"id":"exception-handling-in-objective-c-swift-interop","level":1,"title":"Exception handling in Objective-C/Swift interop","anchor":"#exception-handling-in-objective-c-swift-interop"},{"id":"generate-release-dsyms-on-apple-targets-by-default","level":1,"title":"Generate release .dSYMs on Apple targets by default","anchor":"#generate-release-dsyms-on-apple-targets-by-default"},{"id":"performance-improvements","level":1,"title":"Performance improvements","anchor":"#performance-improvements"},{"id":"simplified-management-of-cocoapods-dependencies","level":1,"title":"Simplified management of CocoaPods dependencies","anchor":"#simplified-management-of-cocoapods-dependencies"},{"id":"kotlin-multiplatform","level":0,"title":"Kotlin Multiplatform","anchor":"#kotlin-multiplatform"},{"id":"sharing-code-in-several-targets-with-the-hierarchical-project-structure","level":1,"title":"Sharing code in several targets with the hierarchical project structure","anchor":"#sharing-code-in-several-targets-with-the-hierarchical-project-structure"},{"id":"leveraging-native-libs-in-the-hierarchical-structure","level":1,"title":"Leveraging native libs in the hierarchical structure","anchor":"#leveraging-native-libs-in-the-hierarchical-structure"},{"id":"specifying-dependencies-only-once","level":1,"title":"Specifying dependencies only once","anchor":"#specifying-dependencies-only-once"},{"id":"gradle-project-improvements","level":0,"title":"Gradle project improvements","anchor":"#gradle-project-improvements"},{"id":"dependency-on-the-standard-library-added-by-default","level":1,"title":"Dependency on the standard library added by default","anchor":"#dependency-on-the-standard-library-added-by-default"},{"id":"minimum-gradle-version-for-kotlin-projects","level":1,"title":"Minimum Gradle version for Kotlin projects","anchor":"#minimum-gradle-version-for-kotlin-projects"},{"id":"improved-gradle-kts-support-in-the-ide","level":1,"title":"Improved *.gradle.kts support in the IDE","anchor":"#improved-gradle-kts-support-in-the-ide"},{"id":"standard-library","level":0,"title":"Standard library","anchor":"#standard-library"},{"id":"common-exception-processing-api","level":1,"title":"Common exception processing API","anchor":"#common-exception-processing-api"},{"id":"new-functions-for-arrays-and-collections","level":1,"title":"New functions for arrays and collections","anchor":"#new-functions-for-arrays-and-collections"},{"id":"functions-for-string-manipulations","level":1,"title":"Functions for string manipulations","anchor":"#functions-for-string-manipulations"},{"id":"bit-operations","level":1,"title":"Bit operations","anchor":"#bit-operations"},{"id":"delegated-properties-improvements","level":1,"title":"Delegated properties improvements","anchor":"#delegated-properties-improvements"},{"id":"converting-from-ktype-to-java-type","level":1,"title":"Converting from KType to Java Type","anchor":"#converting-from-ktype-to-java-type"},{"id":"proguard-configurations-for-kotlin-reflection","level":1,"title":"Proguard configurations for Kotlin reflection","anchor":"#proguard-configurations-for-kotlin-reflection"},{"id":"improving-the-existing-api","level":1,"title":"Improving the existing API","anchor":"#improving-the-existing-api"},{"id":"module-info-descriptors-for-stdlib-artifacts","level":1,"title":"module-info descriptors for stdlib artifacts","anchor":"#module-info-descriptors-for-stdlib-artifacts"},{"id":"deprecations","level":1,"title":"Deprecations","anchor":"#deprecations"},{"id":"exclusion-of-the-deprecated-experimental-coroutines","level":1,"title":"Exclusion of the deprecated experimental coroutines","anchor":"#exclusion-of-the-deprecated-experimental-coroutines"},{"id":"stable-json-serialization","level":0,"title":"Stable JSON serialization","anchor":"#stable-json-serialization"},{"id":"scripting-and-repl","level":0,"title":"Scripting and REPL","anchor":"#scripting-and-repl"},{"id":"new-dependencies-resolution-api","level":1,"title":"New dependencies resolution API","anchor":"#new-dependencies-resolution-api"},{"id":"new-repl-api","level":1,"title":"New REPL API","anchor":"#new-repl-api"},{"id":"compiled-scripts-cache","level":1,"title":"Compiled scripts cache","anchor":"#compiled-scripts-cache"},{"id":"artifacts-renaming","level":1,"title":"Artifacts renaming","anchor":"#artifacts-renaming"},{"id":"migrating-to-kotlin-1-4-0","level":0,"title":"Migrating to Kotlin 1.4.0","anchor":"#migrating-to-kotlin-1-4-0"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="https://kotlinlang.org/assets/images/favicon.svg?v2"><link rel="icon" type="image/x-icon" sizes="32x32" href="https://kotlinlang.org/assets/images/favicon.ico?v2"><link rel="icon" type="image/png" sizes="96x96" href="https://kotlinlang.org/assets/images/apple-touch-icon.png?v2"><link rel="icon" type="image/png" sizes="300x300" href="https://kotlinlang.org/assets/images/apple-touch-icon-72x72.png?v2"><link rel="icon" type="image/png" sizes="500x500" href="https://kotlinlang.org/assets/images/apple-touch-icon-114x114.png?v2"><meta name="image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- Open Graph --><meta property="og:title" content="What's new in Kotlin 1.4.0 | Kotlin"><meta property="og:description" content=""><meta property="og:image" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><meta property="og:site_name" content="Kotlin Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://kotlinlang.org/docs/whatsnew14.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="What's new in Kotlin 1.4.0 | Kotlin"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://kotlinlang.org/assets/images/open-graph/docs.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://kotlinlang.org/docs/whatsnew14.html#webpage",
    "url": "https://kotlinlang.org/docs/whatsnew14.html",
    "name": "What's new in Kotlin 1.4.0 | Kotlin",
    "description": "",
    "image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://kotlinlang.org/docs/#website",
    "url": "https://kotlinlang.org/docs/",
    "name": "Kotlin Help"
}</script><!-- End Schema.org --><style>a[href="test-page.html"] { visibility: hidden; }</style></head><body data-id="whatsnew14" data-main-title="What's new in Kotlin 1.4.0" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="What's new in Kotlin///Earlier versions" data-edit-url="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/topics/whatsnew/whatsnew14.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="whatsnew14" id="whatsnew14.md">What's new in Kotlin 1.4.0</h1><p id="kzmyhp_2"><span class="emphasis" id="kzmyhp_16"><a href="releases.html#release-details" id="kzmyhp_17">Released: 17 August 2020</a></span></p><p id="kzmyhp_3">In Kotlin 1.4.0, we ship a number of improvements in all of its components, with the <a href="https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/" id="kzmyhp_18" data-external="true" rel="noopener noreferrer" target="_blank">focus on quality and performance</a>. Below you will find the list of the most important changes in Kotlin 1.4.0.</p><section class="chapter"><h2 id="language-features-and-improvements" data-toc="language-features-and-improvements">Language features and improvements</h2><p id="kzmyhp_19">Kotlin 1.4.0 comes with a variety of different language features and improvements. They include:</p><ul class="list _bullet" id="kzmyhp_20"><li class="list__item" id="kzmyhp_27"><p id="kzmyhp_33"><a href="#sam-conversions-for-kotlin-interfaces" id="kzmyhp_34">SAM conversions for Kotlin interfaces</a></p></li><li class="list__item" id="kzmyhp_28"><p id="kzmyhp_35"><a href="#explicit-api-mode-for-library-authors" id="kzmyhp_36">Explicit API mode for library authors</a></p></li><li class="list__item" id="kzmyhp_29"><p id="kzmyhp_37"><a href="#mixing-named-and-positional-arguments" id="kzmyhp_38">Mixing named and positional arguments</a></p></li><li class="list__item" id="kzmyhp_30"><p id="kzmyhp_39"><a href="#trailing-comma" id="kzmyhp_40">Trailing comma</a></p></li><li class="list__item" id="kzmyhp_31"><p id="kzmyhp_41"><a href="#callable-reference-improvements" id="kzmyhp_42">Callable reference improvements</a></p></li><li class="list__item" id="kzmyhp_32"><p id="kzmyhp_43"><a href="#using-break-and-continue-inside-when-expressions-included-in-loops" id="kzmyhp_44">break and continue inside when included in loops</a></p></li></ul><section class="chapter"><h3 id="sam-conversions-for-kotlin-interfaces" data-toc="sam-conversions-for-kotlin-interfaces">SAM conversions for Kotlin interfaces</h3><p id="kzmyhp_45">Before Kotlin 1.4.0, you could apply SAM (Single Abstract Method) conversions only <a href="java-interop.html#sam-conversions" id="kzmyhp_49">when working with Java methods and Java interfaces from Kotlin</a>. From now on, you can use SAM conversions for Kotlin interfaces as well. To do so, mark a Kotlin interface explicitly as functional with the <code class="code" id="kzmyhp_50">fun</code> modifier.</p><p id="kzmyhp_46">SAM conversion applies if you pass a lambda as an argument when an interface with only one single abstract method is expected as a parameter. In this case, the compiler automatically converts the lambda to an instance of the class that implements the abstract member function.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
fun interface IntPredicate {
    fun accept(i: Int): Boolean
}

val isEven = IntPredicate { it % 2 == 0 }

fun main() { 
    println(&quot;Is 7 even? - ${isEven.accept(7)}&quot;)
}
</div><p id="kzmyhp_48"><a href="fun-interfaces.html" id="kzmyhp_51">Learn more about Kotlin functional interfaces and SAM conversions</a>.</p></section><section class="chapter"><h3 id="explicit-api-mode-for-library-authors" data-toc="explicit-api-mode-for-library-authors">Explicit API mode for library authors</h3><p id="kzmyhp_52">Kotlin compiler offers <span class="emphasis" id="kzmyhp_62">explicit API mode</span> for library authors. In this mode, the compiler performs additional checks that help make the library's API clearer and more consistent. It adds the following requirements for declarations exposed to the library's public API:</p><ul class="list _bullet" id="kzmyhp_53"><li class="list__item" id="kzmyhp_63"><p id="kzmyhp_65">Visibility modifiers are required for declarations if the default visibility exposes them to the public API. This helps ensure that no declarations are exposed to the public API unintentionally.</p></li><li class="list__item" id="kzmyhp_64"><p id="kzmyhp_66">Explicit type specifications are required for properties and functions that are exposed to the public API. This guarantees that API users are aware of the types of API members they use.</p></li></ul><p id="kzmyhp_54">Depending on your configuration, these explicit APIs can produce errors (<span class="emphasis" id="kzmyhp_67">strict</span> mode) or warnings (<span class="emphasis" id="kzmyhp_68">warning</span> mode). Certain kinds of declarations are excluded from such checks for the sake of readability and common sense:</p><ul class="list _bullet" id="kzmyhp_55"><li class="list__item" id="kzmyhp_69"><p id="kzmyhp_73">primary constructors</p></li><li class="list__item" id="kzmyhp_70"><p id="kzmyhp_74">properties of data classes</p></li><li class="list__item" id="kzmyhp_71"><p id="kzmyhp_75">property getters and setters</p></li><li class="list__item" id="kzmyhp_72"><p id="kzmyhp_76"><code class="code" id="kzmyhp_77">override</code> methods</p></li></ul><p id="kzmyhp_56">Explicit API mode analyzes only the production sources of a module.</p><p id="kzmyhp_57">To compile your module in the explicit API mode, add the following lines to your Gradle build script:</p><div class="tabs" id="kzmyhp_58" data-group="build-script" data-anchors="[kzmyhp_78,kzmyhp_79]"><div class="tabs__content" data-gtm="tab" id="kzmyhp_78" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
kotlin {    
    // for strict mode
    explicitApi() 
    // or
    explicitApi = ExplicitApiMode.Strict
    
    // for warning mode
    explicitApiWarning()
    // or
    explicitApi = ExplicitApiMode.Warning
}
</div></div><div class="tabs__content" data-gtm="tab" id="kzmyhp_79" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
kotlin {    
    // for strict mode
    explicitApi() 
    // or
    explicitApi = 'strict'
    
    // for warning mode
    explicitApiWarning()
    // or
    explicitApi = 'warning'
}
</div></div></div><p id="kzmyhp_59">When using the command-line compiler, switch to explicit API mode by adding the <code class="code" id="kzmyhp_82">-Xexplicit-api</code> compiler option with the value <code class="code" id="kzmyhp_83">strict</code> or <code class="code" id="kzmyhp_84">warning</code>.</p><div class="code-block" data-lang="bash">
-Xexplicit-api={strict|warning}
</div><p id="kzmyhp_61"><a href="https://github.com/Kotlin/KEEP/blob/master/proposals/explicit-api-mode.md" id="kzmyhp_85" data-external="true" rel="noopener noreferrer" target="_blank">Find more details about the explicit API mode in the KEEP</a>.</p></section><section class="chapter"><h3 id="mixing-named-and-positional-arguments" data-toc="mixing-named-and-positional-arguments">Mixing named and positional arguments</h3><p id="kzmyhp_86">In Kotlin 1.3, when you called a function with <a href="functions.html#named-arguments" id="kzmyhp_90">named arguments</a>, you had to place all the arguments without names (positional arguments) before the first named argument. For example, you could call <code class="code" id="kzmyhp_91">f(1, y = 2)</code>, but you couldn't call <code class="code" id="kzmyhp_92">f(x = 1, 2)</code>.</p><p id="kzmyhp_87">It was really annoying when all the arguments were in their correct positions but you wanted to specify a name for one argument in the middle. It was especially helpful for making absolutely clear which attribute a boolean or <code class="code" id="kzmyhp_93">null</code> value belongs to.</p><p id="kzmyhp_88">In Kotlin 1.4, there is no such limitation &ndash; you can now specify a name for an argument in the middle of a set of positional arguments. Moreover, you can mix positional and named arguments any way you like, as long as they remain in the correct order.</p><div class="code-block" data-lang="kotlin">
fun reformat(
    str: String,
    uppercaseFirstLetter: Boolean = true,
    wordSeparator: Char = ' '
) {
    // ...
}

//Function call with a named argument in the middle
reformat(&quot;This is a String!&quot;, uppercaseFirstLetter = false , '-')
</div></section><section class="chapter"><h3 id="trailing-comma" data-toc="trailing-comma">Trailing comma</h3><p id="kzmyhp_94">With Kotlin 1.4 you can now add a trailing comma in enumerations such as argument and parameter lists, <code class="code" id="kzmyhp_98">when</code> entries, and components of destructuring declarations. With a trailing comma, you can add new items and change their order without adding or removing commas.</p><p id="kzmyhp_95">This is especially helpful if you use multi-line syntax for parameters or values. After adding a trailing comma, you can then easily swap lines with parameters or values.</p><div class="code-block" data-lang="kotlin">
fun reformat(
    str: String,
    uppercaseFirstLetter: Boolean = true,
    wordSeparator: Character = ' ', //trailing comma
) {
    // ...
}
</div><div class="code-block" data-lang="kotlin">
val colors = listOf(
    &quot;red&quot;,
    &quot;green&quot;,
    &quot;blue&quot;, //trailing comma
)
</div></section><section class="chapter"><h3 id="callable-reference-improvements" data-toc="callable-reference-improvements">Callable reference improvements</h3><p id="kzmyhp_99">Kotlin 1.4 supports more cases for using callable references:</p><ul class="list _bullet" id="kzmyhp_100"><li class="list__item" id="kzmyhp_105"><p id="kzmyhp_109">References to functions with default argument values</p></li><li class="list__item" id="kzmyhp_106"><p id="kzmyhp_110">Function references in <code class="code" id="kzmyhp_111">Unit</code>-returning functions</p></li><li class="list__item" id="kzmyhp_107"><p id="kzmyhp_112">References that adapt based on the number of arguments in a function</p></li><li class="list__item" id="kzmyhp_108"><p id="kzmyhp_113">Suspend conversion on callable references</p></li></ul><section class="chapter"><h4 id="references-to-functions-with-default-argument-values" data-toc="references-to-functions-with-default-argument-values">References to functions with default argument values</h4><p id="kzmyhp_114">Now you can use callable references to functions with default argument values. If the callable reference to the function <code class="code" id="kzmyhp_118">foo</code> takes no arguments, the default value <code class="code" id="kzmyhp_119">0</code> is used.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
fun foo(i: Int = 0): String = &quot;$i!&quot;

fun apply(func: () -&gt; String): String = func()

fun main() {
    println(apply(::foo))
}
</div><p id="kzmyhp_116">Previously, you had to write additional overloads for the function <code class="code" id="kzmyhp_120">apply</code> to use the default argument values.</p><div class="code-block" data-lang="kotlin">
// some new overload
fun applyInt(func: (Int) -&gt; String): String = func(0) 
</div></section><section class="chapter"><h4 id="function-references-in-unit-returning-functions" data-toc="function-references-in-unit-returning-functions">Function references in Unit-returning functions</h4><p id="kzmyhp_121">In Kotlin 1.4, you can use callable references to functions returning any type in <code class="code" id="kzmyhp_123">Unit</code>-returning functions. Before Kotlin 1.4, you could only use lambda arguments in this case. Now you can use both lambda arguments and callable references.</p><div class="code-block" data-lang="kotlin">
fun foo(f: () -&gt; Unit) { }
fun returnsInt(): Int = 42

fun main() {
    foo { returnsInt() } // this was the only way to do it  before 1.4
    foo(::returnsInt) // starting from 1.4, this also works
}
</div></section><section class="chapter"><h4 id="references-that-adapt-based-on-the-number-of-arguments-in-a-function" data-toc="references-that-adapt-based-on-the-number-of-arguments-in-a-function">References that adapt based on the number of arguments in a function</h4><p id="kzmyhp_124">Now you can adapt callable references to functions when passing a variable number of arguments (<code class="code" id="kzmyhp_126">vararg</code>) . You can pass any number of parameters of the same type at the end of the list of passed arguments.</p><div class="code-block" data-lang="kotlin">
fun foo(x: Int, vararg y: String) {}

fun use0(f: (Int) -&gt; Unit) {}
fun use1(f: (Int, String) -&gt; Unit) {}
fun use2(f: (Int, String, String) -&gt; Unit) {}

fun test() {
    use0(::foo) 
    use1(::foo) 
    use2(::foo) 
}
</div></section><section class="chapter"><h4 id="suspend-conversion-on-callable-references" data-toc="suspend-conversion-on-callable-references">Suspend conversion on callable references</h4><p id="kzmyhp_127">In addition to suspend conversion on lambdas, Kotlin now supports suspend conversion on callable references starting from version 1.4.0.</p><div class="code-block" data-lang="kotlin">
fun call() {}
fun takeSuspend(f: suspend () -&gt; Unit) {}

fun test() {
    takeSuspend { call() } // OK before 1.4
    takeSuspend(::call) // In Kotlin 1.4, it also works
}
</div></section></section><section class="chapter"><h3 id="using-break-and-continue-inside-when-expressions-included-in-loops" data-toc="using-break-and-continue-inside-when-expressions-included-in-loops">Using break and continue inside when expressions included in loops</h3><p id="kzmyhp_129">In Kotlin 1.3, you could not use unqualified <code class="code" id="kzmyhp_135">break</code> and <code class="code" id="kzmyhp_136">continue</code> inside <code class="code" id="kzmyhp_137">when</code> expressions included in loops. The reason was that these keywords were reserved for possible <a href="https://en.wikipedia.org/wiki/Switch_statement#Fallthrough" id="kzmyhp_138" data-external="true" rel="noopener noreferrer" target="_blank">fall-through behavior</a> in <code class="code" id="kzmyhp_139">when</code> expressions.</p><p id="kzmyhp_130">That's why if you wanted to use <code class="code" id="kzmyhp_140">break</code> and <code class="code" id="kzmyhp_141">continue</code> inside <code class="code" id="kzmyhp_142">when</code> expressions in loops, you had to <a href="returns.html#break-and-continue-labels" id="kzmyhp_143">label</a> them, which became rather cumbersome.</p><div class="code-block" data-lang="kotlin">
fun test(xs: List&lt;Int&gt;) {
    LOOP@for (x in xs) {
        when (x) {
            2 -&gt; continue@LOOP
            17 -&gt; break@LOOP
            else -&gt; println(x)
        }
    }
}
</div><p id="kzmyhp_132">In Kotlin 1.4, you can use <code class="code" id="kzmyhp_144">break</code> and <code class="code" id="kzmyhp_145">continue</code> without labels inside <code class="code" id="kzmyhp_146">when</code> expressions included in loops. They behave as expected by terminating the nearest enclosing loop or proceeding to its next step.</p><div class="code-block" data-lang="kotlin">
fun test(xs: List&lt;Int&gt;) {
    for (x in xs) {
        when (x) {
            2 -&gt; continue
            17 -&gt; break
            else -&gt; println(x)
        }
    }
}
</div><p id="kzmyhp_134">The fall-through behavior inside <code class="code" id="kzmyhp_147">when</code> is subject to further design.</p></section></section><section class="chapter"><h2 id="new-tools-in-the-ide" data-toc="new-tools-in-the-ide">New tools in the IDE</h2><p id="kzmyhp_148">With Kotlin 1.4, you can use the new tools in IntelliJ IDEA to simplify Kotlin development:</p><ul class="list _bullet" id="kzmyhp_149"><li class="list__item" id="kzmyhp_152"><p id="kzmyhp_154"><a href="#new-flexible-project-wizard" id="kzmyhp_155">New flexible Project Wizard</a></p></li><li class="list__item" id="kzmyhp_153"><p id="kzmyhp_156"><a href="#coroutine-debugger" id="kzmyhp_157">Coroutine Debugger</a></p></li></ul><section class="chapter"><h3 id="new-flexible-project-wizard" data-toc="new-flexible-project-wizard">New flexible Project Wizard</h3><p id="kzmyhp_158">With the flexible new Kotlin Project Wizard, you have a place to easily create and configure different types of Kotlin projects, including multiplatform projects, which can be difficult to configure without a UI.</p><figure id="kzmyhp_159"><img alt="Kotlin Project Wizard &ndash; Multiplatform project" src="images/multiplatform-project-1-wn.png" title="Kotlin Project Wizard &ndash; Multiplatform project" width="2046" height="1120"></figure><p id="kzmyhp_160">The new Kotlin Project Wizard is both simple and flexible:</p><ol class="list _decimal" id="kzmyhp_161" type="1"><li class="list__item" id="kzmyhp_168"><p id="kzmyhp_171"><span class="emphasis" id="kzmyhp_172">Select the project template</span>, depending on what you're trying to do. More templates will be added in the future.</p></li><li class="list__item" id="kzmyhp_169"><p id="kzmyhp_173"><span class="emphasis" id="kzmyhp_174">Select the build system</span> &ndash; Gradle (Kotlin or Groovy DSL), Maven, or IntelliJ IDEA. <br> The Kotlin Project Wizard will only show the build systems supported on the selected project template.</p></li><li class="list__item" id="kzmyhp_170"><p id="kzmyhp_176"><span class="emphasis" id="kzmyhp_177">Preview the project structure</span> directly on the main screen.</p></li></ol><p id="kzmyhp_162">Then you can finish creating your project or, optionally, <span class="emphasis" id="kzmyhp_178">configure the project</span> on the next screen:</p><ol class="list _decimal" id="kzmyhp_163" type="1" start="4"><li class="list__item" id="kzmyhp_179"><p id="kzmyhp_181"><span class="emphasis" id="kzmyhp_182">Add/remove modules and targets</span> supported for this project template.</p></li><li class="list__item" id="kzmyhp_180"><p id="kzmyhp_183"><span class="emphasis" id="kzmyhp_184">Configure module and target settings</span>, for example, the target JVM version, target template, and test framework.</p></li></ol><figure id="kzmyhp_164"><img alt="Kotlin Project Wizard - Configure targets" src="images/multiplatform-project-2-wn.png" title="Kotlin Project Wizard - Configure targets" width="2046" height="1120"></figure><p id="kzmyhp_165">In the future, we are going to make the Kotlin Project Wizard even more flexible by adding more configuration options and templates.</p><p id="kzmyhp_166">You can try out the new Kotlin Project Wizard by working through these tutorials:</p><ul class="list _bullet" id="kzmyhp_167"><li class="list__item" id="kzmyhp_185"><p id="kzmyhp_188"><a href="jvm-get-started.html" id="kzmyhp_189">Create a console application based on Kotlin/JVM</a></p></li><li class="list__item" id="kzmyhp_186"><p id="kzmyhp_190"><a href="js-react.html" id="kzmyhp_191">Create a Kotlin/JS application for React</a></p></li><li class="list__item" id="kzmyhp_187"><p id="kzmyhp_192"><a href="native-get-started.html" id="kzmyhp_193">Create a Kotlin/Native application</a></p></li></ul></section><section class="chapter"><h3 id="coroutine-debugger" data-toc="coroutine-debugger">Coroutine Debugger</h3><p id="kzmyhp_194">Many people already use <span id="kzmyhp_204">coroutines</span> for asynchronous programming. But when it came to debugging, working with coroutines before Kotlin 1.4, could be a real pain. Since coroutines jumped between threads, it was difficult to understand what a specific coroutine was doing and check its context. In some cases, tracking steps over breakpoints simply didn't work. As a result, you had to rely on logging or mental effort to debug code that used coroutines.</p><p id="kzmyhp_195">In Kotlin 1.4, debugging coroutines is now much more convenient with the new functionality shipped with the Kotlin plugin.</p><aside class="prompt" data-type="note" data-title="" id="kzmyhp_196"><p id="kzmyhp_205">Debugging works for versions 1.3.8 or later of <code class="code" id="kzmyhp_206">kotlinx-coroutines-core</code>.</p></aside><p id="kzmyhp_197">The <span class="control" id="kzmyhp_207">Debug Tool Window</span> now contains a new <span class="control" id="kzmyhp_208">Coroutines</span> tab. In this tab, you can find information about both currently running and suspended coroutines. The coroutines are grouped by the dispatcher they are running on.</p><figure id="kzmyhp_198"><img alt="Debugging coroutines" src="images/coroutine-debugger-wn.png" title="Debugging coroutines" width="2800" height="612"></figure><p id="kzmyhp_199">Now you can:</p><ul class="list _bullet" id="kzmyhp_200"><li class="list__item" id="kzmyhp_209"><p id="kzmyhp_212">Easily check the state of each coroutine.</p></li><li class="list__item" id="kzmyhp_210"><p id="kzmyhp_213">See the values of local and captured variables for both running and suspended coroutines.</p></li><li class="list__item" id="kzmyhp_211"><p id="kzmyhp_214">See a full coroutine creation stack, as well as a call stack inside the coroutine. The stack includes all frames with variable values, even those that would be lost during standard debugging.</p></li></ul><p id="kzmyhp_201">If you need a full report containing the state of each coroutine and its stack, right-click inside the <span class="control" id="kzmyhp_215">Coroutines</span> tab, and then click <span class="control" id="kzmyhp_216">Get Coroutines Dump</span>. Currently, the coroutines dump is rather simple, but we're going to make it more readable and helpful in future versions of Kotlin.</p><figure id="kzmyhp_202"><img alt="Coroutines Dump" src="images/coroutines-dump-wn.png" title="Coroutines Dump" width="1158" height="334"></figure><p id="kzmyhp_203">Learn more about debugging coroutines in <a href="https://blog.jetbrains.com/kotlin/2020/07/kotlin-1-4-rc-debugging-coroutines/" id="kzmyhp_217" data-external="true" rel="noopener noreferrer" target="_blank">this blog post</a> and <a href="https://www.jetbrains.com/help/idea/debug-kotlin-coroutines.html" id="kzmyhp_218" data-external="true" rel="noopener noreferrer" target="_blank">IntelliJ IDEA documentation</a>.</p></section></section><section class="chapter"><h2 id="new-compiler" data-toc="new-compiler">New compiler</h2><p id="kzmyhp_219">The new Kotlin compiler is going to be really fast; it will unify all the supported platforms and provide an API for compiler extensions. It's a long-term project, and we've already completed several steps in Kotlin 1.4.0:</p><ul class="list _bullet" id="kzmyhp_220"><li class="list__item" id="kzmyhp_223"><p id="kzmyhp_225"><a href="#new-more-powerful-type-inference-algorithm" id="kzmyhp_226">New, more powerful type inference algorithm</a> is enabled by default.</p></li><li class="list__item" id="kzmyhp_224"><p id="kzmyhp_227"><a href="#unified-backends-and-extensibility" id="kzmyhp_228">New JVM and JS IR backends</a>. They will become the default once we stabilize them.</p></li></ul><section class="chapter"><h3 id="new-more-powerful-type-inference-algorithm" data-toc="new-more-powerful-type-inference-algorithm">New more powerful type inference algorithm</h3><p id="kzmyhp_229">Kotlin 1.4 uses a new, more powerful type inference algorithm. This new algorithm was already available to try in Kotlin 1.3 by specifying a compiler option, and now it's used by default. You can find the full list of issues fixed in the new algorithm in <a href="https://youtrack.jetbrains.com/issues/KT?q=Tag:%20fixed-in-new-inference%20" id="kzmyhp_237" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>. Here you can find some of the most noticeable improvements:</p><ul class="list _bullet" id="kzmyhp_230"><li class="list__item" id="kzmyhp_238"><p id="kzmyhp_244"><a href="#more-cases-where-type-is-inferred-automatically" id="kzmyhp_245">More cases where type is inferred automatically</a></p></li><li class="list__item" id="kzmyhp_239"><p id="kzmyhp_246"><a href="#smart-casts-for-a-lambda-s-last-expression" id="kzmyhp_247">Smart casts for a lambda's last expression</a></p></li><li class="list__item" id="kzmyhp_240"><p id="kzmyhp_248"><a href="#smart-casts-for-callable-references" id="kzmyhp_249">Smart casts for callable references</a></p></li><li class="list__item" id="kzmyhp_241"><p id="kzmyhp_250"><a href="#better-inference-for-delegated-properties" id="kzmyhp_251">Better inference for delegated properties</a></p></li><li class="list__item" id="kzmyhp_242"><p id="kzmyhp_252"><a href="#sam-conversion-for-java-interfaces-with-different-arguments" id="kzmyhp_253">SAM conversion for Java interfaces with different arguments</a></p></li><li class="list__item" id="kzmyhp_243"><p id="kzmyhp_254"><a href="#java-sam-interfaces-in-kotlin" id="kzmyhp_255">Java SAM interfaces in Kotlin</a></p></li></ul><section class="chapter"><h4 id="more-cases-where-type-is-inferred-automatically" data-toc="more-cases-where-type-is-inferred-automatically">More cases where type is inferred automatically</h4><p id="kzmyhp_256">The new inference algorithm infers types for many cases where the old algorithm required you to specify them explicitly. For instance, in the following example the type of the lambda parameter <code class="code" id="kzmyhp_259">it</code> is correctly inferred to <code class="code" id="kzmyhp_260">String?</code>:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
//sampleStart
val rulesMap: Map&lt;String, (String?) -&gt; Boolean&gt; = mapOf(
    &quot;weak&quot; to { it != null },
    &quot;medium&quot; to { !it.isNullOrBlank() },
    &quot;strong&quot; to { it != null &amp;&amp; &quot;^[a-zA-Z0-9]+$&quot;.toRegex().matches(it) }
)
//sampleEnd

fun main() {
    println(rulesMap.getValue(&quot;weak&quot;)(&quot;abc!&quot;))
    println(rulesMap.getValue(&quot;strong&quot;)(&quot;abc&quot;))
    println(rulesMap.getValue(&quot;strong&quot;)(&quot;abc!&quot;))
}
</div><p id="kzmyhp_258">In Kotlin 1.3, you needed to introduce an explicit lambda parameter or replace <code class="code" id="kzmyhp_261">to</code> with a <code class="code" id="kzmyhp_262">Pair</code> constructor with explicit generic arguments to make it work.</p></section><section class="chapter"><h4 id="smart-casts-for-a-lambda-s-last-expression" data-toc="smart-casts-for-a-lambda-s-last-expression">Smart casts for a lambda's last expression</h4><p id="kzmyhp_263">In Kotlin 1.3, the last expression inside a lambda wasn't smart cast unless you specified the expected type. Thus, in the following example, Kotlin 1.3 infers <code class="code" id="kzmyhp_267">String?</code> as the type of the <code class="code" id="kzmyhp_268">result</code> variable:</p><div class="code-block" data-lang="kotlin">
val result = run {
    var str = currentValue()
    if (str == null) {
        str = &quot;test&quot;
    }
    str // the Kotlin compiler knows that str is not null here
}
// The type of 'result' is String? in Kotlin 1.3 and String in Kotlin 1.4
</div><p id="kzmyhp_265">In Kotlin 1.4, thanks to the new inference algorithm, the last expression inside a lambda gets smart cast, and this new, more precise type is used to infer the resulting lambda type. Thus, the type of the <code class="code" id="kzmyhp_269">result</code> variable becomes <code class="code" id="kzmyhp_270">String</code>.</p><p id="kzmyhp_266">In Kotlin 1.3, you often needed to add explicit casts (either <code class="code" id="kzmyhp_271">!!</code> or type casts like <code class="code" id="kzmyhp_272">as String</code>) to make such cases work, and now these casts have become unnecessary.</p></section><section class="chapter"><h4 id="smart-casts-for-callable-references" data-toc="smart-casts-for-callable-references">Smart casts for callable references</h4><p id="kzmyhp_273">In Kotlin 1.3, you couldn't access a member reference of a smart cast type. Now in Kotlin 1.4 you can:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
import kotlin.reflect.KFunction

sealed class Animal
class Cat : Animal() {
    fun meow() {
        println(&quot;meow&quot;)
    }
}

class Dog : Animal() {
    fun woof() {
        println(&quot;woof&quot;)
    }
}

//sampleStart
fun perform(animal: Animal) {
    val kFunction: KFunction&lt;*&gt; = when (animal) {
        is Cat -&gt; animal::meow
        is Dog -&gt; animal::woof
    }
    kFunction.call()
}
//sampleEnd

fun main() {
    perform(Cat())
}
</div><p id="kzmyhp_275">You can use different member references <code class="code" id="kzmyhp_276">animal::meow</code> and <code class="code" id="kzmyhp_277">animal::woof</code> after the animal variable has been smart cast to specific types <code class="code" id="kzmyhp_278">Cat</code> and <code class="code" id="kzmyhp_279">Dog</code>. After type checks, you can access member references corresponding to subtypes.</p></section><section class="chapter"><h4 id="better-inference-for-delegated-properties" data-toc="better-inference-for-delegated-properties">Better inference for delegated properties</h4><p id="kzmyhp_280">The type of a delegated property wasn't taken into account while analyzing the delegate expression which follows the <code class="code" id="kzmyhp_282">by</code> keyword. For instance, the following code didn't compile before, but now the compiler correctly infers the types of the <code class="code" id="kzmyhp_283">old</code> and <code class="code" id="kzmyhp_284">new</code> parameters as <code class="code" id="kzmyhp_285">String?</code>:</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
import kotlin.properties.Delegates

fun main() {
    var prop: String? by Delegates.observable(null) { p, old, new -&gt;
        println(&quot;$old → $new&quot;)
    }
    prop = &quot;abc&quot;
    prop = &quot;xyz&quot;
}
</div></section><section class="chapter"><h4 id="sam-conversion-for-java-interfaces-with-different-arguments" data-toc="sam-conversion-for-java-interfaces-with-different-arguments">SAM conversion for Java interfaces with different arguments</h4><p id="kzmyhp_286">Kotlin has supported SAM conversions for Java interfaces from the beginning, but there was one case that wasn't supported, which was sometimes annoying when working with existing Java libraries. If you called a Java method that took two SAM interfaces as parameters, both arguments needed to be either lambdas or regular objects. You couldn't pass one argument as a lambda and another as an object.</p><p id="kzmyhp_287">The new algorithm fixes this issue, and you can pass a lambda instead of a SAM interface in any case, which is the way you'd naturally expect it to work.</p><div class="code-block" data-lang="java">
// FILE: A.java
public class A {
    public static void foo(Runnable r1, Runnable r2) {}
}
</div><div class="code-block" data-lang="kotlin">
// FILE: test.kt
fun test(r1: Runnable) {
    A.foo(r1) {}  // Works in Kotlin 1.4
}
</div></section><section class="chapter"><h4 id="java-sam-interfaces-in-kotlin" data-toc="java-sam-interfaces-in-kotlin">Java SAM interfaces in Kotlin</h4><p id="kzmyhp_290">In Kotlin 1.4, you can use Java SAM interfaces in Kotlin and apply SAM conversions to them.</p><div class="code-block" data-lang="kotlin">
import java.lang.Runnable

fun foo(r: Runnable) {}

fun test() { 
    foo { } // OK
}
</div><p id="kzmyhp_292">In Kotlin 1.3, you would have had to declare the function <code class="code" id="kzmyhp_293">foo</code> above in Java code to perform a SAM conversion.</p></section></section><section class="chapter"><h3 id="unified-backends-and-extensibility" data-toc="unified-backends-and-extensibility">Unified backends and extensibility</h3><p id="kzmyhp_294">In Kotlin, we have three backends that generate executables: Kotlin/JVM, Kotlin/JS, and Kotlin/Native. Kotlin/JVM and Kotlin/JS don't share much code since they were developed independently of each other. Kotlin/Native is based on a new infrastructure built around an intermediate representation (IR) for Kotlin code.</p><p id="kzmyhp_295">We are now migrating Kotlin/JVM and Kotlin/JS to the same IR. As a result, all three backends share a lot of logic and have a unified pipeline. This allows us to implement most features, optimizations, and bug fixes only once for all platforms. Both new IR-based back-ends are in <a href="components-stability.html" id="kzmyhp_298">Alpha</a>.</p><p id="kzmyhp_296">A common backend infrastructure also opens the door for multiplatform compiler extensions. You will be able to plug into the pipeline and add custom processing and transformations that will automatically work for all platforms.</p><p id="kzmyhp_297">We encourage you to use our new <a href="#new-jvm-ir-backend" id="kzmyhp_299">JVM IR</a> and <a href="#new-js-ir-backend" id="kzmyhp_300">JS IR</a> backends, which are currently in Alpha, and share your feedback with us.</p></section></section><section class="chapter"><h2 id="kotlin-jvm" data-toc="kotlin-jvm">Kotlin/JVM</h2><p id="kzmyhp_301">Kotlin 1.4.0 includes a number of JVM-specific improvements, such as:</p><ul class="list _bullet" id="kzmyhp_302"><li class="list__item" id="kzmyhp_307"><p id="kzmyhp_311"><a href="#new-jvm-ir-backend" id="kzmyhp_312">New JVM IR backend</a></p></li><li class="list__item" id="kzmyhp_308"><p id="kzmyhp_313"><a href="#new-modes-for-generating-default-methods" id="kzmyhp_314">New modes for generating default methods in interfaces</a></p></li><li class="list__item" id="kzmyhp_309"><p id="kzmyhp_315"><a href="#unified-exception-type-for-null-checks" id="kzmyhp_316">Unified exception type for null checks</a></p></li><li class="list__item" id="kzmyhp_310"><p id="kzmyhp_317"><a href="#type-annotations-in-the-jvm-bytecode" id="kzmyhp_318">Type annotations in the JVM bytecode</a></p></li></ul><section class="chapter"><h3 id="new-jvm-ir-backend" data-toc="new-jvm-ir-backend">New JVM IR backend</h3><p id="kzmyhp_319">Along with Kotlin/JS, we are migrating Kotlin/JVM to the <a href="#unified-backends-and-extensibility" id="kzmyhp_327">unified IR backend</a>, which allows us to implement most features and bug fixes once for all platforms. You will also be able to benefit from this by creating multiplatform extensions that will work for all platforms.</p><p id="kzmyhp_320">Kotlin 1.4.0 does not provide a public API for such extensions yet, but we are working closely with our partners, including <a href="https://developer.android.com/jetpack/compose" id="kzmyhp_328" data-external="true" rel="noopener noreferrer" target="_blank">Jetpack Compose</a>, who are already building their compiler plugins using our new backend.</p><p id="kzmyhp_321">We encourage you to try out the new Kotlin/JVM backend, which is currently in Alpha, and to file any issues and feature requests to our <a href="https://youtrack.jetbrains.com/issues/KT" id="kzmyhp_329" data-external="true" rel="noopener noreferrer" target="_blank">issue tracker</a>. This will help us to unify the compiler pipelines and bring compiler extensions like Jetpack Compose to the Kotlin community more quickly.</p><p id="kzmyhp_322">To enable the new JVM IR backend, specify an additional compiler option in your Gradle build script:</p><div class="code-block" data-lang="kotlin">
kotlinOptions.useIR = true
</div><aside class="prompt" data-type="note" data-title="" id="kzmyhp_324"><p id="kzmyhp_330">If you <a href="https://developer.android.com/jetpack/compose/setup?hl=en" id="kzmyhp_331" data-external="true" rel="noopener noreferrer" target="_blank">enable Jetpack Compose</a>, you will automatically be opted in to the new JVM backend without needing to specify the compiler option in <code class="code" id="kzmyhp_332">kotlinOptions</code>.</p></aside><p id="kzmyhp_325">When using the command-line compiler, add the compiler option <code class="code" id="kzmyhp_333">-Xuse-ir</code>.</p><aside class="prompt" data-type="note" data-title="" id="kzmyhp_326"><p id="kzmyhp_334">You can use code compiled by the new JVM IR backend only if you've enabled the new backend. Otherwise, you will get an error. Considering this, we don't recommend that library authors switch to the new backend in production.</p></aside></section><section class="chapter"><h3 id="new-modes-for-generating-default-methods" data-toc="new-modes-for-generating-default-methods">New modes for generating default methods</h3><p id="kzmyhp_335">When compiling Kotlin code to targets JVM 1.8 and above, you could compile non-abstract methods of Kotlin interfaces into Java's <code class="code" id="kzmyhp_338">default</code> methods. For this purpose, there was a mechanism that includes the <code class="code" id="kzmyhp_339">@JvmDefault</code> annotation for marking such methods and the <code class="code" id="kzmyhp_340">-Xjvm-default</code> compiler option that enables processing of this annotation.</p><p id="kzmyhp_336">In 1.4.0, we've added a new mode for generating default methods: <code class="code" id="kzmyhp_341">-Xjvm-default=all</code> compiles <span class="emphasis" id="kzmyhp_342">all</span> non-abstract methods of Kotlin interfaces to <code class="code" id="kzmyhp_343">default</code> Java methods. For compatibility with the code that uses the interfaces compiled without <code class="code" id="kzmyhp_344">default</code>, we also added <code class="code" id="kzmyhp_345">all-compatibility</code> mode.</p><p id="kzmyhp_337">For more information about default methods in the Java interop, see the <a href="java-to-kotlin-interop.html#default-methods-in-interfaces" id="kzmyhp_346">interoperability documentation</a> and <a href="https://blog.jetbrains.com/kotlin/2020/07/kotlin-1-4-m3-generating-default-methods-in-interfaces/" id="kzmyhp_347" data-external="true" rel="noopener noreferrer" target="_blank">this blog post</a>.</p></section><section class="chapter"><h3 id="unified-exception-type-for-null-checks" data-toc="unified-exception-type-for-null-checks">Unified exception type for null checks</h3><p id="kzmyhp_348">Starting from Kotlin 1.4.0, all runtime null checks will throw a <code class="code" id="kzmyhp_351">java.lang.NullPointerException</code> instead of <code class="code" id="kzmyhp_352">KotlinNullPointerException</code>, <code class="code" id="kzmyhp_353">IllegalStateException</code>, <code class="code" id="kzmyhp_354">IllegalArgumentException</code>, and <code class="code" id="kzmyhp_355">TypeCastException</code>. This applies to: the <code class="code" id="kzmyhp_356">!!</code> operator, parameter null checks in the method preamble, platform-typed expression null checks, and the <code class="code" id="kzmyhp_357">as</code> operator with a non-nullable type. This doesn't apply to <code class="code" id="kzmyhp_358">lateinit</code> null checks and explicit library function calls like <code class="code" id="kzmyhp_359">checkNotNull</code> or <code class="code" id="kzmyhp_360">requireNotNull</code>.</p><p id="kzmyhp_349">This change increases the number of possible null check optimizations that can be performed either by the Kotlin compiler or by various kinds of bytecode processing tools, such as the Android <a href="https://developer.android.com/studio/build/shrink-code" id="kzmyhp_361" data-external="true" rel="noopener noreferrer" target="_blank">R8 optimizer</a>.</p><p id="kzmyhp_350">Note that from a developer's perspective, things won't change that much: the Kotlin code will throw exceptions with the same error messages as before. The type of exception changes, but the information passed stays the same.</p></section><section class="chapter"><h3 id="type-annotations-in-the-jvm-bytecode" data-toc="type-annotations-in-the-jvm-bytecode">Type annotations in the JVM bytecode</h3><p id="kzmyhp_362">Kotlin can now generate type annotations in the JVM bytecode (target version 1.8+), so that they become available in Java reflection at runtime. To emit the type annotation in the bytecode, follow these steps:</p><ol class="list _decimal" id="kzmyhp_363" type="1"><li class="list__item" id="kzmyhp_369"><p id="kzmyhp_372">Make sure that your declared annotation has a proper annotation target (Java's <code class="code" id="kzmyhp_373">ElementType.TYPE_USE</code> or Kotlin's <code class="code" id="kzmyhp_374">AnnotationTarget.TYPE</code>) and retention (<code class="code" id="kzmyhp_375">AnnotationRetention.RUNTIME</code>).</p></li><li class="list__item" id="kzmyhp_370"><p id="kzmyhp_376">Compile the annotation class declaration to JVM bytecode target version 1.8+. You can specify it with <code class="code" id="kzmyhp_377">-jvm-target=1.8</code> compiler option.</p></li><li class="list__item" id="kzmyhp_371"><p id="kzmyhp_378">Compile the code that uses the annotation to JVM bytecode target version 1.8+ (<code class="code" id="kzmyhp_379">-jvm-target=1.8</code>) and add the <code class="code" id="kzmyhp_380">-Xemit-jvm-type-annotations</code> compiler option.</p></li></ol><p id="kzmyhp_364">Note that the type annotations from the standard library aren't emitted in the bytecode for now because the standard library is compiled with the target version 1.6.</p><p id="kzmyhp_365">So far, only the basic cases are supported:</p><ul class="list _bullet" id="kzmyhp_366"><li class="list__item" id="kzmyhp_381"><p id="kzmyhp_383">Type annotations on method parameters, method return types and property types;</p></li><li class="list__item" id="kzmyhp_382"><p id="kzmyhp_384">Invariant projections of type arguments, such as <code class="code" id="kzmyhp_385">Smth&lt;@Ann Foo&gt;</code>, <code class="code" id="kzmyhp_386">Array&lt;@Ann Foo&gt;</code>.</p></li></ul><p id="kzmyhp_367">In the following example, the <code class="code" id="kzmyhp_387">@Foo</code> annotation on the <code class="code" id="kzmyhp_388">String</code> type can be emitted to the bytecode and then used by the library code:</p><div class="code-block" data-lang="kotlin">
@Target(AnnotationTarget.TYPE)
annotation class Foo

class A {
    fun foo(): @Foo String = &quot;OK&quot;
}
</div></section></section><section class="chapter"><h2 id="kotlin-js" data-toc="kotlin-js">Kotlin/JS</h2><p id="kzmyhp_389">On the JS platform, Kotlin 1.4.0 provides the following improvements:</p><ul class="list _bullet" id="kzmyhp_390"><li class="list__item" id="kzmyhp_393"><p id="kzmyhp_395"><a href="#new-gradle-dsl" id="kzmyhp_396">New Gradle DSL</a></p></li><li class="list__item" id="kzmyhp_394"><p id="kzmyhp_397"><a href="#new-js-ir-backend" id="kzmyhp_398">New JS IR backend</a></p></li></ul><section class="chapter"><h3 id="new-gradle-dsl" data-toc="new-gradle-dsl">New Gradle DSL</h3><p id="kzmyhp_399">The <code class="code" id="kzmyhp_401">kotlin.js</code> Gradle plugin comes with an adjusted Gradle DSL, which provides a number of new configuration options and is more closely aligned to the DSL used by the <code class="code" id="kzmyhp_402">kotlin-multiplatform</code> plugin. Some of the most impactful changes include:</p><ul class="list _bullet" id="kzmyhp_400"><li class="list__item" id="kzmyhp_403"><p id="kzmyhp_407">Explicit toggles for the creation of executable files via <code class="code" id="kzmyhp_408">binaries.executable()</code>. Read more about the <a href="js-project-setup.html#execution-environments" id="kzmyhp_409">executing Kotlin/JS and its environment here</a>.</p></li><li class="list__item" id="kzmyhp_404"><p id="kzmyhp_410">Configuration of webpack's CSS and style loaders from within the Gradle configuration via <code class="code" id="kzmyhp_411">cssSupport</code>. Read more about <a href="js-project-setup.html#css" id="kzmyhp_412">using CSS and style loaders here</a>.</p></li><li class="list__item" id="kzmyhp_405"><p id="kzmyhp_413">Improved management for npm dependencies, with mandatory version numbers or <a href="https://docs.npmjs.com/about-semantic-versioning" id="kzmyhp_414" data-external="true" rel="noopener noreferrer" target="_blank">semver</a> version ranges, as well as support for <span class="emphasis" id="kzmyhp_415">development</span>, <span class="emphasis" id="kzmyhp_416">peer</span>, and <span class="emphasis" id="kzmyhp_417">optional</span> npm dependencies using <code class="code" id="kzmyhp_418">devNpm</code>, <code class="code" id="kzmyhp_419">optionalNpm</code> and <code class="code" id="kzmyhp_420">peerNpm</code>. <a href="js-project-setup.html#npm-dependencies" id="kzmyhp_421">Read more about dependency management for npm packages directly from Gradle here</a>.</p></li><li class="list__item" id="kzmyhp_406"><p id="kzmyhp_422">Stronger integrations for <a href="https://github.com/Kotlin/dukat" id="kzmyhp_423" data-external="true" rel="noopener noreferrer" target="_blank">Dukat</a>, the generator for Kotlin external declarations. External declarations can now be generated at build time, or can be manually generated via a Gradle task.</p></li></ul></section><section class="chapter"><h3 id="new-js-ir-backend" data-toc="new-js-ir-backend">New JS IR backend</h3><p id="kzmyhp_424">The <a href="js-ir-compiler.html" id="kzmyhp_430">IR backend for Kotlin/JS</a>, which currently has <a href="components-stability.html" id="kzmyhp_431">Alpha</a> stability, provides some new functionality specific to the Kotlin/JS target which is focused around the generated code size through dead code elimination, and improved interoperation with JavaScript and TypeScript, among others.</p><p id="kzmyhp_425">To enable the Kotlin/JS IR backend, set the key <code class="code" id="kzmyhp_432">kotlin.js.compiler=ir</code> in your <code class="code" id="kzmyhp_433">gradle.properties</code>, or pass the <code class="code" id="kzmyhp_434">IR</code> compiler type to the <code class="code" id="kzmyhp_435">js</code> function of your Gradle build script:</p><div class="code-block" data-lang="groovy">
kotlin {
    js(IR) { // or: LEGACY, BOTH
        // ...
    }
    binaries.executable()
}
</div><p id="kzmyhp_427">For more detailed information about how to configure the new backend, check out the <a href="js-ir-compiler.html" id="kzmyhp_436">Kotlin/JS IR compiler documentation</a>.</p><p id="kzmyhp_428">With the new <a href="js-to-kotlin-interop.html#jsexport-annotation" id="kzmyhp_437">@JsExport</a> annotation and the ability to <span class="control" id="kzmyhp_438"><a href="js-ir-compiler.html#preview-generation-of-typescript-declaration-files-d-ts" id="kzmyhp_440">generate TypeScript definitions</a> from Kotlin code</span>, the Kotlin/JS IR compiler backend improves JavaScript &amp; TypeScript interoperability. This also makes it easier to integrate Kotlin/JS code with existing tooling, to create <span class="control" id="kzmyhp_439">hybrid applications</span> and leverage code-sharing functionality in multiplatform projects.</p><p id="kzmyhp_429"><a href="js-ir-compiler.html" id="kzmyhp_441">Learn more about the available features in the Kotlin/JS IR compiler backend</a>.</p></section></section><section class="chapter"><h2 id="kotlin-native" data-toc="kotlin-native">Kotlin/Native</h2><p id="kzmyhp_442">In 1.4.0, Kotlin/Native got a significant number of new features and improvements, including:</p><ul class="list _bullet" id="kzmyhp_443"><li class="list__item" id="kzmyhp_450"><p id="kzmyhp_456"><a href="#support-for-kotlin-s-suspending-functions-in-swift-and-objective-c" id="kzmyhp_457">Support for suspending functions in Swift and Objective-C</a></p></li><li class="list__item" id="kzmyhp_451"><p id="kzmyhp_458"><a href="#objective-c-generics-support-by-default" id="kzmyhp_459">Objective-C generics support by default</a></p></li><li class="list__item" id="kzmyhp_452"><p id="kzmyhp_460"><a href="#exception-handling-in-objective-c-swift-interop" id="kzmyhp_461">Exception handling in Objective-C/Swift interop</a></p></li><li class="list__item" id="kzmyhp_453"><p id="kzmyhp_462"><a href="#generate-release-dsyms-on-apple-targets-by-default" id="kzmyhp_463">Generate release .dSYMs on Apple targets by default</a></p></li><li class="list__item" id="kzmyhp_454"><p id="kzmyhp_464"><a href="#performance-improvements" id="kzmyhp_465">Performance improvements</a></p></li><li class="list__item" id="kzmyhp_455"><p id="kzmyhp_466"><a href="#simplified-management-of-cocoapods-dependencies" id="kzmyhp_467">Simplified management of CocoaPods dependencies</a></p></li></ul><section class="chapter"><h3 id="support-for-kotlin-s-suspending-functions-in-swift-and-objective-c" data-toc="support-for-kotlin-s-suspending-functions-in-swift-and-objective-c">Support for Kotlin's suspending functions in Swift and Objective-C</h3><p id="kzmyhp_468">In 1.4.0, we add the basic support for suspending functions in Swift and Objective-C. Now, when you compile a Kotlin module into an Apple framework, suspending functions are available in it as functions with callbacks (<code class="code" id="kzmyhp_474">completionHandler</code> in the Swift/Objective-C terminology). When you have such functions in the generated framework's header, you can call them from your Swift or Objective-C code and even override them.</p><p id="kzmyhp_469">For example, if you write this Kotlin function:</p><div class="code-block" data-lang="kotlin">
suspend fun queryData(id: Int): String = ...
</div><p id="kzmyhp_471">...then you can call it from Swift like so:</p><div class="code-block" data-lang="swift">
queryData(id: 17) { result, error in
   if let e = error {
       print(&quot;ERROR: \(e)&quot;)
   } else {
       print(result!)
   }
}
</div><p id="kzmyhp_473"><a href="native-objc-interop.html" id="kzmyhp_475">Learn more about using suspending functions in Swift and Objective-C</a>.</p></section><section class="chapter"><h3 id="objective-c-generics-support-by-default" data-toc="objective-c-generics-support-by-default">Objective-C generics support by default</h3><p id="kzmyhp_476">Previous versions of Kotlin provided experimental support for generics in Objective-C interop. Since 1.4.0, Kotlin/Native generates Apple frameworks with generics from Kotlin code by default. In some cases, this may break existing Objective-C or Swift code calling Kotlin frameworks. To have the framework header written without generics, add the <code class="code" id="kzmyhp_479">-Xno-objc-generics</code> compiler option.</p><div class="code-block" data-lang="kotlin">
kotlin {
    targets.withType&lt;org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget&gt; {
        binaries.all {
            freeCompilerArgs += &quot;-Xno-objc-generics&quot;
        }
    }
}
</div><p id="kzmyhp_478">Please note that all specifics and limitations listed in the <a href="native-objc-interop.html#generics" id="kzmyhp_480">documentation on interoperability with Objective-C</a> are still valid.</p></section><section class="chapter"><h3 id="exception-handling-in-objective-c-swift-interop" data-toc="exception-handling-in-objective-c-swift-interop">Exception handling in Objective-C/Swift interop</h3><p id="kzmyhp_481">In 1.4.0, we slightly change the Swift API generated from Kotlin with respect to the way exceptions are translated. There is a fundamental difference in error handling between Kotlin and Swift. All Kotlin exceptions are unchecked, while Swift has only checked errors. Thus, to make Swift code aware of expected exceptions, Kotlin functions should be marked with a <code class="code" id="kzmyhp_484">@Throws</code> annotation specifying a list of potential exception classes.</p><p id="kzmyhp_482">When compiling to Swift or the Objective-C framework, functions that have or are inheriting <code class="code" id="kzmyhp_485">@Throws</code> annotation are represented as <code class="code" id="kzmyhp_486">NSError*</code>-producing methods in Objective-C and as <code class="code" id="kzmyhp_487">throws</code> methods in Swift.</p><p id="kzmyhp_483">Previously, any exceptions other than <code class="code" id="kzmyhp_488">RuntimeException</code> and <code class="code" id="kzmyhp_489">Error</code> were propagated as <code class="code" id="kzmyhp_490">NSError</code>. Now this behavior changes: now <code class="code" id="kzmyhp_491">NSError</code> is thrown only for exceptions that are instances of classes specified as parameters of <code class="code" id="kzmyhp_492">@Throws</code> annotation (or their subclasses). Other Kotlin exceptions that reach Swift/Objective-C are considered unhandled and cause program termination.</p></section><section class="chapter"><h3 id="generate-release-dsyms-on-apple-targets-by-default" data-toc="generate-release-dsyms-on-apple-targets-by-default">Generate release .dSYMs on Apple targets by default</h3><p id="kzmyhp_493">Starting with 1.4.0, the Kotlin/Native compiler produces <a href="https://developer.apple.com/documentation/xcode/building_your_app_to_include_debugging_information" id="kzmyhp_496" data-external="true" rel="noopener noreferrer" target="_blank">debug symbol files</a> (<code class="code" id="kzmyhp_497">.dSYM</code>s) for release binaries on Darwin platforms by default. This can be disabled with the <code class="code" id="kzmyhp_498">-Xadd-light-debug=disable</code> compiler option. On other platforms, this option is disabled by default. To toggle this option in Gradle, use:</p><div class="code-block" data-lang="kotlin">
kotlin {
    targets.withType&lt;org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget&gt; {
        binaries.all {
            freeCompilerArgs += &quot;-Xadd-light-debug={enable|disable}&quot;
        }
    }
}
</div><p id="kzmyhp_495"><a href="native-ios-symbolication.html" id="kzmyhp_499">Learn more about crash report symbolication</a>.</p></section><section class="chapter"><h3 id="performance-improvements" data-toc="performance-improvements">Performance improvements</h3><p id="kzmyhp_500">Kotlin/Native has received a number of performance improvements that speed up both the development process and execution. Here are some examples:</p><ul class="list _bullet" id="kzmyhp_501"><li class="list__item" id="kzmyhp_502"><p id="kzmyhp_506">To improve the speed of object allocation, we now offer the <a href="https://github.com/microsoft/mimalloc" id="kzmyhp_507" data-external="true" rel="noopener noreferrer" target="_blank">mimalloc</a> memory allocator as an alternative to the system allocator. mimalloc works up to two times faster on some benchmarks. Currently, the usage of mimalloc in Kotlin/Native is experimental; you can switch to it using the <code class="code" id="kzmyhp_508">-Xallocator=mimalloc</code> compiler option.</p></li><li class="list__item" id="kzmyhp_503"><p id="kzmyhp_509">We've reworked how C interop libraries are built. With the new tooling, Kotlin/Native produces interop libraries up to 4 times as fast as before, and artifacts are 25% to 30% the size they used to be.</p></li><li class="list__item" id="kzmyhp_504"><p id="kzmyhp_510">Overall runtime performance has improved because of optimizations in GC. This improvement will be especially apparent in projects with a large number of long-lived objects. <code class="code" id="kzmyhp_511">HashMap</code> and <code class="code" id="kzmyhp_512">HashSet</code> collections now work faster by escaping redundant boxing.</p></li><li class="list__item" id="kzmyhp_505"><p id="kzmyhp_513">In 1.3.70 we introduced two new features for improving the performance of Kotlin/Native compilation: <a href="https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-3-70-released/#kotlin-native" id="kzmyhp_514" data-external="true" rel="noopener noreferrer" target="_blank">caching project dependencies and running the compiler from the Gradle daemon</a>. Since that time, we've managed to fix numerous issues and improve the overall stability of these features.</p></li></ul></section><section class="chapter"><h3 id="simplified-management-of-cocoapods-dependencies" data-toc="simplified-management-of-cocoapods-dependencies">Simplified management of CocoaPods dependencies</h3><p id="kzmyhp_515">Previously, once you integrated your project with the dependency manager CocoaPods, you could build an iOS, macOS, watchOS, or tvOS part of your project only in Xcode, separate from other parts of your multiplatform project. These other parts could be built in IntelliJ IDEA.</p><p id="kzmyhp_516">Moreover, every time you added a dependency on an Objective-C library stored in CocoaPods (Pod library), you had to switch from IntelliJ IDEA to Xcode, call <code class="code" id="kzmyhp_523">pod install</code>, and run the Xcode build there.</p><p id="kzmyhp_517">Now you can manage Pod dependencies right in IntelliJ IDEA while enjoying the benefits it provides for working with code, such as code highlighting and completion. You can also build the whole Kotlin project with Gradle, without having to switch to Xcode. This means you only have to go to Xcode when you need to write Swift/Objective-C code or run your application on a simulator or device.</p><p id="kzmyhp_518">Now you can also work with Pod libraries stored locally.</p><p id="kzmyhp_519">Depending on your needs, you can add dependencies between:</p><ul class="list _bullet" id="kzmyhp_520"><li class="list__item" id="kzmyhp_524"><p id="kzmyhp_526">A Kotlin project and Pod libraries stored remotely in the CocoaPods repository or stored locally on your machine.</p></li><li class="list__item" id="kzmyhp_525"><p id="kzmyhp_527">A Kotlin Pod (Kotlin project used as a CocoaPods dependency) and an Xcode project with one or more targets.</p></li></ul><p id="kzmyhp_521">Complete the initial configuration, and when you add a new dependency to <code class="code" id="kzmyhp_528">cocoapods</code>, just re-import the project in IntelliJ IDEA. The new dependency will be added automatically. No additional steps are required.</p><p id="kzmyhp_522"><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-cocoapods-libraries.html" id="kzmyhp_529" data-external="true" rel="noopener noreferrer" target="_blank">Learn how to add dependencies</a>.</p></section></section><section class="chapter"><h2 id="kotlin-multiplatform" data-toc="kotlin-multiplatform">Kotlin Multiplatform</h2><aside class="prompt" data-type="warning" data-title="" id="kzmyhp_530"><p id="kzmyhp_537">Support for multiplatform projects is in <a href="components-stability.html" id="kzmyhp_538">Alpha</a>. It may change incompatibly and require manual migration in the future. We appreciate your feedback on it in <a href="https://youtrack.jetbrains.com/issues/KT" id="kzmyhp_539" data-external="true" rel="noopener noreferrer" target="_blank">YouTrack</a>.</p></aside><p id="kzmyhp_531"><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/get-started.html" id="kzmyhp_540" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin Multiplatform</a> reduces time spent writing and maintaining the same code for <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-dsl-reference.html#targets" id="kzmyhp_541" data-external="true" rel="noopener noreferrer" target="_blank">different platforms</a> while retaining the flexibility and benefits of native programming. We continue investing our effort in multiplatform features and improvements:</p><ul class="list _bullet" id="kzmyhp_532"><li class="list__item" id="kzmyhp_542"><p id="kzmyhp_545"><a href="#sharing-code-in-several-targets-with-the-hierarchical-project-structure" id="kzmyhp_546">Sharing code in several targets with the hierarchical project structure</a></p></li><li class="list__item" id="kzmyhp_543"><p id="kzmyhp_547"><a href="#leveraging-native-libs-in-the-hierarchical-structure" id="kzmyhp_548">Leveraging native libs in the hierarchical structure</a></p></li><li class="list__item" id="kzmyhp_544"><p id="kzmyhp_549"><a href="#specifying-dependencies-only-once" id="kzmyhp_550">Specifying kotlinx dependencies only once</a></p></li></ul><aside class="prompt" data-type="note" data-title="" id="kzmyhp_533"><p id="kzmyhp_551">Multiplatform projects require Gradle 6.0 or later.</p></aside><section class="chapter"><h3 id="sharing-code-in-several-targets-with-the-hierarchical-project-structure" data-toc="sharing-code-in-several-targets-with-the-hierarchical-project-structure">Sharing code in several targets with the hierarchical project structure</h3><p id="kzmyhp_552">With the new hierarchical project structure support, you can share code among <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-dsl-reference.html#targets" id="kzmyhp_565" data-external="true" rel="noopener noreferrer" target="_blank">several platforms</a> in a <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-discover-project.html" id="kzmyhp_566" data-external="true" rel="noopener noreferrer" target="_blank">multiplatform project</a>.</p><p id="kzmyhp_553">Previously, any code added to a multiplatform project could be placed either in a platform-specific source set, which is limited to one target and can't be reused by any other platform, or in a common source set, like <code class="code" id="kzmyhp_567">commonMain</code> or <code class="code" id="kzmyhp_568">commonTest</code>, which is shared across all the platforms in the project. In the common source set, you could only call a platform-specific API by using an <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-expect-actual.html" id="kzmyhp_569" data-external="true" rel="noopener noreferrer" target="_blank"><code class="code" id="kzmyhp_570">expect</code> declaration that needs platform-specific <code class="code" id="kzmyhp_571">actual</code> implementations</a>.</p><p id="kzmyhp_554">This made it easy to <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-share-on-platforms.html#share-code-on-all-platforms" id="kzmyhp_572" data-external="true" rel="noopener noreferrer" target="_blank">share code on all platforms</a>, but it was not so easy to <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-share-on-platforms.html#share-code-on-similar-platforms" id="kzmyhp_573" data-external="true" rel="noopener noreferrer" target="_blank">share between only some of the targets</a>, especially similar ones that could potentially reuse a lot of the common logic and third-party APIs.</p><p id="kzmyhp_555">For example, in a typical multiplatform project targeting iOS, there are two iOS-related targets: one for iOS ARM64 devices, and the other for the x64 simulator. They have separate platform-specific source sets, but in practice, there is rarely a need for different code for the device and simulator, and their dependencies are much alike. So iOS-specific code could be shared between them.</p><p id="kzmyhp_556">Apparently, in this setup, it would be desirable to have a <span class="emphasis" id="kzmyhp_574">shared source set for two iOS targets</span>, with Kotlin/Native code that could still directly call any of the APIs that are common to both the iOS device and the simulator.</p><figure id="kzmyhp_557"><img alt="Code shared for iOS targets" src="images/iosmain-hierarchy.png" title="Code shared for iOS targets" width="300" height="120"></figure><p id="kzmyhp_558">Now you can do this with the <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-share-on-platforms.html#share-code-on-similar-platforms" id="kzmyhp_575" data-external="true" rel="noopener noreferrer" target="_blank">hierarchical project structure support</a>, which infers and adapts the API and language features available in each source set based on which targets consume them.</p><p id="kzmyhp_559">For common combinations of targets, you can create a hierarchical structure with target shortcuts. For example, create two iOS targets and the shared source set shown above with the <code class="code" id="kzmyhp_576">ios()</code> shortcut:</p><div class="code-block" data-lang="kotlin">
kotlin {
    ios() // iOS device and simulator targets; iosMain and iosTest source sets
}
</div><p id="kzmyhp_561">For other combinations of targets, <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-hierarchy.html#manual-configuration" id="kzmyhp_577" data-external="true" rel="noopener noreferrer" target="_blank">create a hierarchy manually</a> by connecting the source sets with the <code class="code" id="kzmyhp_578">dependsOn</code> relation.</p><figure id="kzmyhp_562"><img alt="Hierarchical structure" src="images/manual-hierarchical-structure.svg" title="Hierarchical structure" width="706" height="349"></figure><div class="tabs" id="kzmyhp_563" data-group="build-script" data-anchors="[kzmyhp_579,kzmyhp_580]"><div class="tabs__content" data-gtm="tab" id="kzmyhp_579" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
kotlin{
    sourceSets {
        val desktopMain by creating {
            dependsOn(commonMain)
        }
        val linuxX64Main by getting {
            dependsOn(desktopMain)
        }
        val mingwX64Main by getting {
            dependsOn(desktopMain)
        }
        val macosX64Main by getting {
            dependsOn(desktopMain)
        }
    }
}
</div></div><div class="tabs__content" data-gtm="tab" id="kzmyhp_580" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
kotlin {
    sourceSets {
        desktopMain {
            dependsOn(commonMain)
        }
        linuxX64Main {
            dependsOn(desktopMain)
        }
        mingwX64Main {
            dependsOn(desktopMain)
        }
        macosX64Main {
            dependsOn(desktopMain)
        }
    }
}

</div></div></div><p id="kzmyhp_564">Thanks to the hierarchical project structure, libraries can also provide common APIs for a subset of targets. Learn more about <a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-share-on-platforms.html#share-code-in-libraries" id="kzmyhp_583" data-external="true" rel="noopener noreferrer" target="_blank">sharing code in libraries</a>.</p></section><section class="chapter"><h3 id="leveraging-native-libs-in-the-hierarchical-structure" data-toc="leveraging-native-libs-in-the-hierarchical-structure">Leveraging native libs in the hierarchical structure</h3><p id="kzmyhp_584">You can use platform-dependent libraries, such as Foundation, UIKit, and POSIX, in source sets shared among several native targets. This can help you share more native code without being limited by platform-specific dependencies.</p><p id="kzmyhp_585">No additional steps are required &ndash; everything is done automatically. IntelliJ IDEA will help you detect common declarations that you can use in the shared code.</p><p id="kzmyhp_586"><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-share-on-platforms.html#connect-platform-specific-libraries" id="kzmyhp_587" data-external="true" rel="noopener noreferrer" target="_blank">Learn more about usage of platform-dependent libraries</a>.</p></section><section class="chapter"><h3 id="specifying-dependencies-only-once" data-toc="specifying-dependencies-only-once">Specifying dependencies only once</h3><p id="kzmyhp_588">From now on, instead of specifying dependencies on different variants of the same library in shared and platform-specific source sets where it is used, you should specify a dependency only once in the shared source set.</p><div class="tabs" id="kzmyhp_589" data-group="build-script" data-anchors="[kzmyhp_595,kzmyhp_596]"><div class="tabs__content" data-gtm="tab" id="kzmyhp_595" data-sync-tabs="kotlin" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
kotlin {
    sourceSets {
        val commonMain by getting {
            dependencies {
                implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.2&quot;)
            }
        }
    }
}
</div></div><div class="tabs__content" data-gtm="tab" id="kzmyhp_596" data-sync-tabs="groovy" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
kotlin {
    sourceSets {
        commonMain {
            dependencies {
                implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.2'
            }
        }
    }
}
</div></div></div><p id="kzmyhp_590">Don't use kotlinx library artifact names with suffixes specifying the platform, such as <code class="code" id="kzmyhp_599">-common</code>, <code class="code" id="kzmyhp_600">-native</code>, or similar, as they are NOT supported anymore. Instead, use the library base artifact name, which in the example above is <code class="code" id="kzmyhp_601">kotlinx-coroutines-core</code>.</p><p id="kzmyhp_591">However, the change doesn't currently affect:</p><ul class="list _bullet" id="kzmyhp_592"><li class="list__item" id="kzmyhp_602"><p id="kzmyhp_604">The <code class="code" id="kzmyhp_605">stdlib</code> library &ndash; starting from Kotlin 1.4.0, <a href="#dependency-on-the-standard-library-added-by-default" id="kzmyhp_606">the stdlib dependency is added automatically</a>.</p></li><li class="list__item" id="kzmyhp_603"><p id="kzmyhp_607">The <code class="code" id="kzmyhp_608">kotlin.test</code> library &ndash; you should still use <code class="code" id="kzmyhp_609">test-common</code> and <code class="code" id="kzmyhp_610">test-annotations-common</code>. These dependencies will be addressed later.</p></li></ul><p id="kzmyhp_593">If you need a dependency only for a specific platform, you can still use platform-specific variants of standard and kotlinx libraries with such suffixes as <code class="code" id="kzmyhp_611">-jvm</code> or<code class="code" id="kzmyhp_612">-js</code>, for example <code class="code" id="kzmyhp_613">kotlinx-coroutines-core-jvm</code>.</p><p id="kzmyhp_594"><a href="gradle-configure-project.html#configure-dependencies" id="kzmyhp_614">Learn more about configuring dependencies</a>.</p></section></section><section class="chapter"><h2 id="gradle-project-improvements" data-toc="gradle-project-improvements">Gradle project improvements</h2><p id="kzmyhp_615">Besides Gradle project features and improvements that are specific to <a href="#kotlin-multiplatform" id="kzmyhp_620">Kotlin Multiplatform</a>, <a href="#kotlin-jvm" id="kzmyhp_621">Kotlin/JVM</a>, <a href="#kotlin-native" id="kzmyhp_622">Kotlin/Native</a>, and <a href="#kotlin-js" id="kzmyhp_623">Kotlin/JS</a>, there are several changes applicable to all Kotlin Gradle projects:</p><ul class="list _bullet" id="kzmyhp_616"><li class="list__item" id="kzmyhp_624"><p id="kzmyhp_627"><a href="#dependency-on-the-standard-library-added-by-default" id="kzmyhp_628">Dependency on the standard library is now added by default</a></p></li><li class="list__item" id="kzmyhp_625"><p id="kzmyhp_629"><a href="#minimum-gradle-version-for-kotlin-projects" id="kzmyhp_630">Kotlin projects require a recent version of Gradle</a></p></li><li class="list__item" id="kzmyhp_626"><p id="kzmyhp_631"><a href="#improved-gradle-kts-support-in-the-ide" id="kzmyhp_632">Improved support for Kotlin Gradle DSL in the IDE</a></p></li></ul><section class="chapter"><h3 id="dependency-on-the-standard-library-added-by-default" data-toc="dependency-on-the-standard-library-added-by-default">Dependency on the standard library added by default</h3><p id="kzmyhp_633">You no longer need to declare a dependency on the <code class="code" id="kzmyhp_637">stdlib</code> library in any Kotlin Gradle project, including a multiplatform one. The dependency is added by default.</p><p id="kzmyhp_634">The automatically added standard library will be the same version of the Kotlin Gradle plugin, since they have the same versioning.</p><p id="kzmyhp_635">For platform-specific source sets, the corresponding platform-specific variant of the library is used, while a common standard library is added to the rest. The Kotlin Gradle plugin will select the appropriate JVM standard library depending on the <code class="code" id="kzmyhp_638">kotlinOptions.jvmTarget</code> <a href="gradle-compiler-options.html" id="kzmyhp_639">compiler option</a> of your Gradle build script.</p><p id="kzmyhp_636"><a href="gradle-configure-project.html#dependency-on-the-standard-library" id="kzmyhp_640">Learn how to change the default behavior</a>.</p></section><section class="chapter"><h3 id="minimum-gradle-version-for-kotlin-projects" data-toc="minimum-gradle-version-for-kotlin-projects">Minimum Gradle version for Kotlin projects</h3><p id="kzmyhp_641">To enjoy the new features in your Kotlin projects, update Gradle to the <a href="https://gradle.org/releases/" id="kzmyhp_642" data-external="true" rel="noopener noreferrer" target="_blank">latest version</a>. Multiplatform projects require Gradle 6.0 or later, while other Kotlin projects work with Gradle 5.4 or later.</p></section><section class="chapter"><h3 id="improved-gradle-kts-support-in-the-ide" data-toc="improved-gradle-kts-support-in-the-ide">Improved *.gradle.kts support in the IDE</h3><p id="kzmyhp_643">In 1.4.0, we continued improving the IDE support for Gradle Kotlin DSL scripts (<code class="code" id="kzmyhp_645">*.gradle.kts</code> files). Here is what the new version brings:</p><ul class="list _bullet" id="kzmyhp_644"><li class="list__item" id="kzmyhp_646"><p id="kzmyhp_648"><span class="emphasis" id="kzmyhp_658">Explicit loading of script configurations</span> for better performance. Previously, the changes you make to the build script were loaded automatically in the background. To improve the performance, we've disabled the automatic loading of build script configuration in 1.4.0. Now the IDE loads the changes only when you explicitly apply them.</p><p id="kzmyhp_649">In Gradle versions earlier than 6.0, you need to manually load the script configuration by clicking <span class="control" id="kzmyhp_659">Load Configuration</span> in the editor.</p><figure id="kzmyhp_650"><img alt="*.gradle.kts &ndash; Load Configuration" src="images/gradle-kts-load-config.png" title="*.gradle.kts &ndash; Load Configuration" width="1565" height="276"></figure><p id="kzmyhp_651">In Gradle 6.0 and above, you can explicitly apply changes by clicking <span class="control" id="kzmyhp_660">Load Gradle Changes</span> or by reimporting the Gradle project.</p><p id="kzmyhp_652">We've added one more action in IntelliJ IDEA 2020.1 with Gradle 6.0 and above &ndash; <span class="control" id="kzmyhp_661">Load Script Configurations</span>, which loads changes to the script configurations without updating the whole project. This takes much less time than reimporting the whole project.</p><figure id="kzmyhp_653"><img alt="*.gradle.kts &ndash; Load Script Changes and Load Gradle Changes" src="images/gradle-kts.png" title="*.gradle.kts &ndash; Load Script Changes and Load Gradle Changes" width="1154" height="299"></figure><p id="kzmyhp_654">You should also <span class="control" id="kzmyhp_662">Load Script Configurations</span> for newly created scripts or when you open a project with new Kotlin plugin for the first time.</p><p id="kzmyhp_655">With Gradle 6.0 and above, you are now able to load all scripts at once as opposed to the previous implementation where they were loaded individually. Since each request requires the Gradle configuration phase to be executed, this could be resource-intensive for large Gradle projects.</p><p id="kzmyhp_656">Currently, such loading is limited to <code class="code" id="kzmyhp_663">build.gradle.kts</code> and <code class="code" id="kzmyhp_664">settings.gradle.kts</code> files (please vote for the related <a href="https://github.com/gradle/gradle/issues/12640" id="kzmyhp_665" data-external="true" rel="noopener noreferrer" target="_blank">issue</a>). To enable highlighting for <code class="code" id="kzmyhp_666">init.gradle.kts</code> or applied <a href="https://docs.gradle.org/current/userguide/plugins.html#sec:script_plugins" id="kzmyhp_667" data-external="true" rel="noopener noreferrer" target="_blank">script plugins</a>, use the old mechanism &ndash; adding them to standalone scripts. Configuration for that scripts will be loaded separately when you need it. You can also enable auto-reload for such scripts.</p><figure id="kzmyhp_657"><img alt="*.gradle.kts &ndash; Add to standalone scripts" src="images/gradle-kts-standalone.png" title="*.gradle.kts &ndash; Add to standalone scripts" width="1585" height="319"></figure></li><li class="list__item" id="kzmyhp_647"><p id="kzmyhp_668"><span class="emphasis" id="kzmyhp_669">Better error reporting</span>. Previously you could only see errors from the Gradle Daemon in separate log files. Now the Gradle Daemon returns all the information about errors directly and shows it in the Build tool window. This saves you both time and effort.</p></li></ul></section></section><section class="chapter"><h2 id="standard-library" data-toc="standard-library">Standard library</h2><p id="kzmyhp_670">Here is the list of the most significant changes to the Kotlin standard library in 1.4.0:</p><ul class="list _bullet" id="kzmyhp_671"><li class="list__item" id="kzmyhp_683"><p id="kzmyhp_694"><a href="#common-exception-processing-api" id="kzmyhp_695">Common exception processing API</a></p></li><li class="list__item" id="kzmyhp_684"><p id="kzmyhp_696"><a href="#new-functions-for-arrays-and-collections" id="kzmyhp_697">New functions for arrays and collections</a></p></li><li class="list__item" id="kzmyhp_685"><p id="kzmyhp_698"><a href="#functions-for-string-manipulations" id="kzmyhp_699">Functions for string manipulations</a></p></li><li class="list__item" id="kzmyhp_686"><p id="kzmyhp_700"><a href="#bit-operations" id="kzmyhp_701">Bit operations</a></p></li><li class="list__item" id="kzmyhp_687"><p id="kzmyhp_702"><a href="#delegated-properties-improvements" id="kzmyhp_703">Delegated properties improvements</a></p></li><li class="list__item" id="kzmyhp_688"><p id="kzmyhp_704"><a href="#converting-from-ktype-to-java-type" id="kzmyhp_705">Converting from KType to Java Type</a></p></li><li class="list__item" id="kzmyhp_689"><p id="kzmyhp_706"><a href="#proguard-configurations-for-kotlin-reflection" id="kzmyhp_707">Proguard configurations for Kotlin reflection</a></p></li><li class="list__item" id="kzmyhp_690"><p id="kzmyhp_708"><a href="#improving-the-existing-api" id="kzmyhp_709">Improving the existing API</a></p></li><li class="list__item" id="kzmyhp_691"><p id="kzmyhp_710"><a href="#module-info-descriptors-for-stdlib-artifacts" id="kzmyhp_711">module-info descriptors for stdlib artifacts</a></p></li><li class="list__item" id="kzmyhp_692"><p id="kzmyhp_712"><a href="#deprecations" id="kzmyhp_713">Deprecations</a></p></li><li class="list__item" id="kzmyhp_693"><p id="kzmyhp_714"><a href="#exclusion-of-the-deprecated-experimental-coroutines" id="kzmyhp_715">Exclusion of the deprecated experimental coroutines</a></p></li></ul><section class="chapter"><h3 id="common-exception-processing-api" data-toc="common-exception-processing-api">Common exception processing API</h3><p id="kzmyhp_716">The following API elements have been moved to the common library:</p><ul class="list _bullet" id="kzmyhp_717"><li class="list__item" id="kzmyhp_718"><p id="kzmyhp_721"><code class="code" id="kzmyhp_722">Throwable.stackTraceToString()</code> extension function, which returns the detailed description of this throwable with its stack trace, and <code class="code" id="kzmyhp_723">Throwable.printStackTrace()</code>, which prints this description to the standard error output.</p></li><li class="list__item" id="kzmyhp_719"><p id="kzmyhp_724"><code class="code" id="kzmyhp_725">Throwable.addSuppressed()</code> function, which lets you specify the exceptions that were suppressed in order to deliver the exception, and the <code class="code" id="kzmyhp_726">Throwable.suppressedExceptions</code> property, which returns a list of all the suppressed exceptions.</p></li><li class="list__item" id="kzmyhp_720"><p id="kzmyhp_727"><code class="code" id="kzmyhp_728">@Throws</code> annotation, which lists exception types that will be checked when the function is compiled to a platform method (on JVM or native platforms).</p></li></ul></section><section class="chapter"><h3 id="new-functions-for-arrays-and-collections" data-toc="new-functions-for-arrays-and-collections">New functions for arrays and collections</h3><section class="chapter"><h4 id="collections" data-toc="collections">Collections</h4><p id="kzmyhp_732">In 1.4.0, the standard library includes a number of useful functions for working with <span class="control" id="kzmyhp_734">collections</span>:</p><ul class="list _bullet" id="kzmyhp_733"><li class="list__item" id="kzmyhp_735"><p id="kzmyhp_745"><code class="code" id="kzmyhp_748">setOfNotNull()</code>, which makes a set consisting of all the non-null items among the provided arguments.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
fun main() {
//sampleStart
    val set = setOfNotNull(null, 1, 2, 0, null)
    println(set)
//sampleEnd
}
</div><p id="kzmyhp_747"></p></li><li class="list__item" id="kzmyhp_736"><p id="kzmyhp_749"><code class="code" id="kzmyhp_752">shuffled()</code> for sequences.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
fun main() {
//sampleStart
    val numbers = (0 until 50).asSequence()
    val result = numbers.map { it * 2 }.shuffled().take(5)
    println(result.toList()) //five random even numbers below 100
//sampleEnd
}
</div><p id="kzmyhp_751"></p></li><li class="list__item" id="kzmyhp_737"><p id="kzmyhp_753"><code class="code" id="kzmyhp_756">*Indexed()</code> counterparts for <code class="code" id="kzmyhp_757">onEach()</code> and <code class="code" id="kzmyhp_758">flatMap()</code>. The operation that they apply to the collection elements has the element index as a parameter.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
fun main() {
//sampleStart
    listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;).onEachIndexed {
        index, item -&gt; println(index.toString() + &quot;:&quot; + item)
    }

   val list = listOf(&quot;hello&quot;, &quot;kot&quot;, &quot;lin&quot;, &quot;world&quot;)
          val kotlin = list.flatMapIndexed { index, item -&gt;
              if (index in 1..2) item.toList() else emptyList() 
          }
//sampleEnd
          println(kotlin)
}
</div><p id="kzmyhp_755"></p></li><li class="list__item" id="kzmyhp_738"><p id="kzmyhp_759"><code class="code" id="kzmyhp_762">*OrNull()</code> counterparts <code class="code" id="kzmyhp_763">randomOrNull()</code>, <code class="code" id="kzmyhp_764">reduceOrNull()</code>, and <code class="code" id="kzmyhp_765">reduceIndexedOrNull()</code>. They return <code class="code" id="kzmyhp_766">null</code> on empty collections.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
fun main() {
//sampleStart
     val empty = emptyList&lt;Int&gt;()
     empty.reduceOrNull { a, b -&gt; a + b }
     //empty.reduce { a, b -&gt; a + b } // Exception: Empty collection can't be reduced.
//sampleEnd
}
</div><p id="kzmyhp_761"></p></li><li class="list__item" id="kzmyhp_739"><p id="kzmyhp_767"><code class="code" id="kzmyhp_770">runningFold()</code>, its synonym <code class="code" id="kzmyhp_771">scan()</code>, and <code class="code" id="kzmyhp_772">runningReduce()</code> apply the given operation to the collection elements sequentially, similarly to<code class="code" id="kzmyhp_773">fold()</code> and <code class="code" id="kzmyhp_774">reduce()</code>; the difference is that these new functions return the whole sequence of intermediate results.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
fun main() {
//sampleStart
    val numbers = mutableListOf(0, 1, 2, 3, 4, 5)
    val runningReduceSum = numbers.runningReduce { sum, item -&gt; sum + item }
    val runningFoldSum = numbers.runningFold(10) { sum, item -&gt; sum + item }
//sampleEnd
    println(runningReduceSum.toString())
    println(runningFoldSum.toString())
}
</div><p id="kzmyhp_769"></p></li><li class="list__item" id="kzmyhp_740"><p id="kzmyhp_775"><code class="code" id="kzmyhp_778">sumOf()</code> takes a selector function and returns a sum of its values for all elements of a collection. <code class="code" id="kzmyhp_779">sumOf()</code> can produce sums of the types <code class="code" id="kzmyhp_780">Int</code>, <code class="code" id="kzmyhp_781">Long</code>, <code class="code" id="kzmyhp_782">Double</code>, <code class="code" id="kzmyhp_783">UInt</code>, and <code class="code" id="kzmyhp_784">ULong</code>. On the JVM, <code class="code" id="kzmyhp_785">BigInteger</code> and <code class="code" id="kzmyhp_786">BigDecimal</code> are also available.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
data class OrderItem(val name: String, val price: Double, val count: Int)

fun main() {
//sampleStart
    val order = listOf&lt;OrderItem&gt;(
        OrderItem(&quot;Cake&quot;, price = 10.0, count = 1),
        OrderItem(&quot;Coffee&quot;, price = 2.5, count = 3),
        OrderItem(&quot;Tea&quot;, price = 1.5, count = 2))

    val total = order.sumOf { it.price * it.count } // Double
    val count = order.sumOf { it.count } // Int
//sampleEnd
    println(&quot;You've ordered $count items that cost $total in total&quot;)
}
</div><p id="kzmyhp_777"></p></li><li class="list__item" id="kzmyhp_741"><p id="kzmyhp_787">The <code class="code" id="kzmyhp_788">min()</code> and <code class="code" id="kzmyhp_789">max()</code> functions have been renamed to <code class="code" id="kzmyhp_790">minOrNull()</code> and <code class="code" id="kzmyhp_791">maxOrNull()</code> to comply with the naming convention used across the Kotlin collections API. An <code class="code" id="kzmyhp_792">*OrNull</code> suffix in the function name means that it returns <code class="code" id="kzmyhp_793">null</code> if the receiver collection is empty. The same applies to <code class="code" id="kzmyhp_794">minBy()</code>, <code class="code" id="kzmyhp_795">maxBy()</code>, <code class="code" id="kzmyhp_796">minWith()</code>, <code class="code" id="kzmyhp_797">maxWith()</code> &ndash; in 1.4, they have <code class="code" id="kzmyhp_798">*OrNull()</code> synonyms.</p></li><li class="list__item" id="kzmyhp_742"><p id="kzmyhp_799">The new <code class="code" id="kzmyhp_803">minOf()</code> and <code class="code" id="kzmyhp_804">maxOf()</code> extension functions return the minimum and the maximum value of the given selector function on the collection items.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
data class OrderItem(val name: String, val price: Double, val count: Int)

fun main() {
//sampleStart
    val order = listOf&lt;OrderItem&gt;(
        OrderItem(&quot;Cake&quot;, price = 10.0, count = 1),
        OrderItem(&quot;Coffee&quot;, price = 2.5, count = 3),
        OrderItem(&quot;Tea&quot;, price = 1.5, count = 2))
    val highestPrice = order.maxOf { it.price }
//sampleEnd
    println(&quot;The most expensive item in the order costs $highestPrice&quot;)
}
</div><p id="kzmyhp_801"></p><p id="kzmyhp_802">There are also <code class="code" id="kzmyhp_805">minOfWith()</code> and <code class="code" id="kzmyhp_806">maxOfWith()</code>, which take a <code class="code" id="kzmyhp_807">Comparator</code> as an argument, and <code class="code" id="kzmyhp_808">*OrNull()</code> versions of all four functions that return <code class="code" id="kzmyhp_809">null</code> on empty collections.</p></li><li class="list__item" id="kzmyhp_743"><p id="kzmyhp_810">New overloads for <code class="code" id="kzmyhp_814">flatMap</code> and <code class="code" id="kzmyhp_815">flatMapTo</code> let you use transformations with return types that don't match the receiver type, namely:</p><ul class="list _bullet" id="kzmyhp_811"><li class="list__item" id="kzmyhp_816"><p id="kzmyhp_818">Transformations to <code class="code" id="kzmyhp_819">Sequence</code> on <code class="code" id="kzmyhp_820">Iterable</code>, <code class="code" id="kzmyhp_821">Array</code>, and <code class="code" id="kzmyhp_822">Map</code></p></li><li class="list__item" id="kzmyhp_817"><p id="kzmyhp_823">Transformations to <code class="code" id="kzmyhp_824">Iterable</code> on <code class="code" id="kzmyhp_825">Sequence</code></p></li></ul><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
fun main() {
//sampleStart
    val list = listOf(&quot;kot&quot;, &quot;lin&quot;)
    val lettersList = list.flatMap { it.asSequence() }
    val lettersSeq = list.asSequence().flatMap { it.toList() }    
//sampleEnd
    println(lettersList)
    println(lettersSeq.toList())
}
</div><p id="kzmyhp_813"></p></li><li class="list__item" id="kzmyhp_744"><p id="kzmyhp_826"><code class="code" id="kzmyhp_827">removeFirst()</code> and <code class="code" id="kzmyhp_828">removeLast()</code> shortcuts for removing elements from mutable lists, and <code class="code" id="kzmyhp_829">*orNull()</code> counterparts of these functions.</p></li></ul></section><section class="chapter"><h4 id="arrays" data-toc="arrays">Arrays</h4><p id="kzmyhp_830">To provide a consistent experience when working with different container types, we've also added new functions for <span class="control" id="kzmyhp_836">arrays</span>:</p><ul class="list _bullet" id="kzmyhp_831"><li class="list__item" id="kzmyhp_837"><p id="kzmyhp_843"><code class="code" id="kzmyhp_844">shuffle()</code> puts the array elements in a random order.</p></li><li class="list__item" id="kzmyhp_838"><p id="kzmyhp_845"><code class="code" id="kzmyhp_846">onEach()</code> performs the given action on each array element and returns the array itself.</p></li><li class="list__item" id="kzmyhp_839"><p id="kzmyhp_847"><code class="code" id="kzmyhp_848">associateWith()</code> and <code class="code" id="kzmyhp_849">associateWithTo()</code> build maps with the array elements as keys.</p></li><li class="list__item" id="kzmyhp_840"><p id="kzmyhp_850"><code class="code" id="kzmyhp_851">reverse()</code> for array subranges reverses the order of the elements in the subrange.</p></li><li class="list__item" id="kzmyhp_841"><p id="kzmyhp_852"><code class="code" id="kzmyhp_853">sortDescending()</code> for array subranges sorts the elements in the subrange in descending order.</p></li><li class="list__item" id="kzmyhp_842"><p id="kzmyhp_854"><code class="code" id="kzmyhp_855">sort()</code> and <code class="code" id="kzmyhp_856">sortWith()</code> for array subranges are now available in the common library.</p></li></ul><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
fun main() {
//sampleStart
    var language = &quot;&quot;
    val letters = arrayOf(&quot;k&quot;, &quot;o&quot;, &quot;t&quot;, &quot;l&quot;, &quot;i&quot;, &quot;n&quot;)
    val fileExt = letters.onEach { language += it }
       .filterNot { it in &quot;aeuio&quot; }.take(2)
       .joinToString(prefix = &quot;.&quot;, separator = &quot;&quot;)
    println(language) // &quot;kotlin&quot;
    println(fileExt) // &quot;.kt&quot;

    letters.shuffle()
    letters.reverse(0, 3)
    letters.sortDescending(2, 5)
    println(letters.contentToString()) // [k, o, t, l, i, n]
//sampleEnd
}
</div><p id="kzmyhp_833">Additionally, there are new functions for conversions between <code class="code" id="kzmyhp_857">CharArray</code>/<code class="code" id="kzmyhp_858">ByteArray</code> and <code class="code" id="kzmyhp_859">String</code>:</p><ul class="list _bullet" id="kzmyhp_834"><li class="list__item" id="kzmyhp_860"><p id="kzmyhp_862"><code class="code" id="kzmyhp_863">ByteArray.decodeToString()</code> and <code class="code" id="kzmyhp_864">String.encodeToByteArray()</code></p></li><li class="list__item" id="kzmyhp_861"><p id="kzmyhp_865"><code class="code" id="kzmyhp_866">CharArray.concatToString()</code> and <code class="code" id="kzmyhp_867">String.toCharArray()</code></p></li></ul><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
fun main() {
//sampleStart
	val str = &quot;kotlin&quot;
    val array = str.toCharArray()
    println(array.concatToString())
//sampleEnd
}
</div></section><section class="chapter"><h4 id="arraydeque" data-toc="arraydeque">ArrayDeque</h4><p id="kzmyhp_868">We've also added the <code class="code" id="kzmyhp_871">ArrayDeque</code> class &ndash; an implementation of a double-ended queue. A double-ended queue lets you add or remove elements both at the beginning or end of the queue in an amortized constant time. You can use a double-ended queue by default when you need a queue or a stack in your code.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
fun main() {
    val deque = ArrayDeque(listOf(1, 2, 3))

    deque.addFirst(0)
    deque.addLast(4)
    println(deque) // [0, 1, 2, 3, 4]

    println(deque.first()) // 0
    println(deque.last()) // 4

    deque.removeFirst()
    deque.removeLast()
    println(deque) // [1, 2, 3]
}
</div><p id="kzmyhp_870">The <code class="code" id="kzmyhp_872">ArrayDeque</code> implementation uses a resizable array underneath: it stores the contents in a circular buffer, an <code class="code" id="kzmyhp_873">Array</code>, and resizes this <code class="code" id="kzmyhp_874">Array</code> only when it becomes full.</p></section></section><section class="chapter"><h3 id="functions-for-string-manipulations" data-toc="functions-for-string-manipulations">Functions for string manipulations</h3><p id="kzmyhp_875">The standard library in 1.4.0 includes a number of improvements in the API for string manipulation:</p><ul class="list _bullet" id="kzmyhp_876"><li class="list__item" id="kzmyhp_877"><p id="kzmyhp_880"><code class="code" id="kzmyhp_883">StringBuilder</code> has useful new extension functions: <code class="code" id="kzmyhp_884">set()</code>, <code class="code" id="kzmyhp_885">setRange()</code>, <code class="code" id="kzmyhp_886">deleteAt()</code>, <code class="code" id="kzmyhp_887">deleteRange()</code>, <code class="code" id="kzmyhp_888">appendRange()</code>, and others.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
    fun main() {
    //sampleStart
        val sb = StringBuilder(&quot;Bye Kotlin 1.3.72&quot;)
        sb.deleteRange(0, 3)
        sb.insertRange(0, &quot;Hello&quot;, 0 ,5)
        sb.set(15, '4')
        sb.setRange(17, 19, &quot;0&quot;)
        print(sb.toString())
    //sampleEnd
    }
</div><p id="kzmyhp_882"></p></li><li class="list__item" id="kzmyhp_878"><p id="kzmyhp_889">Some existing functions of <code class="code" id="kzmyhp_890">StringBuilder</code> are available in the common library. Among them are <code class="code" id="kzmyhp_891">append()</code>, <code class="code" id="kzmyhp_892">insert()</code>, <code class="code" id="kzmyhp_893">substring()</code>, <code class="code" id="kzmyhp_894">setLength()</code>, and more.</p></li><li class="list__item" id="kzmyhp_879"><p id="kzmyhp_895">New functions <code class="code" id="kzmyhp_898">Appendable.appendLine()</code> and <code class="code" id="kzmyhp_899">StringBuilder.appendLine()</code> have been added to the common library. They replace the JVM-only <code class="code" id="kzmyhp_900">appendln()</code> functions of these classes.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
fun main() {
//sampleStart
    println(buildString {
        appendLine(&quot;Hello,&quot;)
        appendLine(&quot;world&quot;)
    })
//sampleEnd
}
</div><p id="kzmyhp_897"></p></li></ul></section><section class="chapter"><h3 id="bit-operations" data-toc="bit-operations">Bit operations</h3><p id="kzmyhp_901">New functions for bit manipulations:</p><ul class="list _bullet" id="kzmyhp_902"><li class="list__item" id="kzmyhp_904"><p id="kzmyhp_910"><code class="code" id="kzmyhp_911">countOneBits()</code></p></li><li class="list__item" id="kzmyhp_905"><p id="kzmyhp_912"><code class="code" id="kzmyhp_913">countLeadingZeroBits()</code></p></li><li class="list__item" id="kzmyhp_906"><p id="kzmyhp_914"><code class="code" id="kzmyhp_915">countTrailingZeroBits()</code></p></li><li class="list__item" id="kzmyhp_907"><p id="kzmyhp_916"><code class="code" id="kzmyhp_917">takeHighestOneBit()</code></p></li><li class="list__item" id="kzmyhp_908"><p id="kzmyhp_918"><code class="code" id="kzmyhp_919">takeLowestOneBit()</code></p></li><li class="list__item" id="kzmyhp_909"><p id="kzmyhp_920"><code class="code" id="kzmyhp_921">rotateLeft()</code> and <code class="code" id="kzmyhp_922">rotateRight()</code> (experimental)</p></li></ul><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
fun main() {
//sampleStart
    val number = &quot;1010000&quot;.toInt(radix = 2)
    println(number.countOneBits())
    println(number.countTrailingZeroBits())
    println(number.takeHighestOneBit().toString(2))
//sampleEnd
}
</div></section><section class="chapter"><h3 id="delegated-properties-improvements" data-toc="delegated-properties-improvements">Delegated properties improvements</h3><p id="kzmyhp_923">In 1.4.0, we have added new features to improve your experience with delegated properties in Kotlin:</p><ul class="list _bullet" id="kzmyhp_924"><li class="list__item" id="kzmyhp_927"><p id="kzmyhp_930">Now a property can be delegated to another property.</p></li><li class="list__item" id="kzmyhp_928"><p id="kzmyhp_931">A new interface <code class="code" id="kzmyhp_932">PropertyDelegateProvider</code> helps create delegate providers in a single declaration.</p></li><li class="list__item" id="kzmyhp_929"><p id="kzmyhp_933"><code class="code" id="kzmyhp_934">ReadWriteProperty</code> now extends <code class="code" id="kzmyhp_935">ReadOnlyProperty</code> so you can use both of them for read-only properties.</p></li></ul><p id="kzmyhp_925">Aside from the new API, we've made some optimizations that reduce the resulting bytecode size. These optimizations are described in <a href="https://blog.jetbrains.com/kotlin/2019/12/what-to-expect-in-kotlin-1-4-and-beyond/#delegated-properties" id="kzmyhp_936" data-external="true" rel="noopener noreferrer" target="_blank">this blog post</a>.</p><p id="kzmyhp_926"><a href="delegated-properties.html" id="kzmyhp_937">Learn more about delegated properties</a>.</p></section><section class="chapter"><h3 id="converting-from-ktype-to-java-type" data-toc="converting-from-ktype-to-java-type">Converting from KType to Java Type</h3><p id="kzmyhp_938">A new extension property <code class="code" id="kzmyhp_940">KType.javaType</code> (currently experimental) in the stdlib helps you obtain a <code class="code" id="kzmyhp_941">java.lang.reflect.Type</code> from a Kotlin type without using the whole <code class="code" id="kzmyhp_942">kotlin-reflect</code> dependency.</p><div class="code-block" data-lang="kotlin" data-runnable="true" data-min-compiler-version="1.4">
import kotlin.reflect.javaType
import kotlin.reflect.typeOf

@OptIn(ExperimentalStdlibApi::class)
inline fun &lt;reified T&gt; accessReifiedTypeArg() {
   val kType = typeOf&lt;T&gt;()
   println(&quot;Kotlin type: $kType&quot;)
   println(&quot;Java type: ${kType.javaType}&quot;)
}

@OptIn(ExperimentalStdlibApi::class)
fun main() {
   accessReifiedTypeArg&lt;String&gt;()
   // Kotlin type: kotlin.String
   // Java type: class java.lang.String
  
   accessReifiedTypeArg&lt;List&lt;String&gt;&gt;()
   // Kotlin type: kotlin.collections.List&lt;kotlin.String&gt;
   // Java type: java.util.List&lt;java.lang.String&gt;
}
</div></section><section class="chapter"><h3 id="proguard-configurations-for-kotlin-reflection" data-toc="proguard-configurations-for-kotlin-reflection">Proguard configurations for Kotlin reflection</h3><p id="kzmyhp_943">Starting from 1.4.0, we have embedded Proguard/R8 configurations for Kotlin Reflection in <code class="code" id="kzmyhp_944">kotlin-reflect.jar</code>. With this in place, most Android projects using R8 or Proguard should work with kotlin-reflect without needing any additional configuration. You no longer need to copy-paste the Proguard rules for kotlin-reflect internals. But note that you still need to explicitly list all the APIs you're going to reflect on.</p></section><section class="chapter"><h3 id="improving-the-existing-api" data-toc="improving-the-existing-api">Improving the existing API</h3><ul class="list _bullet" id="kzmyhp_945"><li class="list__item" id="kzmyhp_946"><p id="kzmyhp_950">Several functions now work on null receivers, for example:</p><ul class="list _bullet" id="kzmyhp_951"><li class="list__item" id="kzmyhp_952"><p id="kzmyhp_954"><code class="code" id="kzmyhp_955">toBoolean()</code> on strings</p></li><li class="list__item" id="kzmyhp_953"><p id="kzmyhp_956"><code class="code" id="kzmyhp_957">contentEquals()</code>, <code class="code" id="kzmyhp_958">contentHashcode()</code>, <code class="code" id="kzmyhp_959">contentToString()</code> on arrays</p></li></ul></li><li class="list__item" id="kzmyhp_947"><p id="kzmyhp_960"><code class="code" id="kzmyhp_961">NaN</code>, <code class="code" id="kzmyhp_962">NEGATIVE_INFINITY</code>, and <code class="code" id="kzmyhp_963">POSITIVE_INFINITY</code> in <code class="code" id="kzmyhp_964">Double</code> and <code class="code" id="kzmyhp_965">Float</code> are now defined as <code class="code" id="kzmyhp_966">const</code>, so you can use them as annotation arguments.</p></li><li class="list__item" id="kzmyhp_948"><p id="kzmyhp_967">New constants <code class="code" id="kzmyhp_968">SIZE_BITS</code> and <code class="code" id="kzmyhp_969">SIZE_BYTES</code> in <code class="code" id="kzmyhp_970">Double</code> and <code class="code" id="kzmyhp_971">Float</code> contain the number of bits and bytes used to represent an instance of the type in binary form.</p></li><li class="list__item" id="kzmyhp_949"><p id="kzmyhp_972">The <code class="code" id="kzmyhp_973">maxOf()</code> and <code class="code" id="kzmyhp_974">minOf()</code> top-level functions can accept a variable number of arguments (<code class="code" id="kzmyhp_975">vararg</code>).</p></li></ul></section><section class="chapter"><h3 id="module-info-descriptors-for-stdlib-artifacts" data-toc="module-info-descriptors-for-stdlib-artifacts">module-info descriptors for stdlib artifacts</h3><p id="kzmyhp_976">Kotlin 1.4.0 adds <code class="code" id="kzmyhp_977">module-info.java</code> module information to default standard library artifacts. This lets you use them with <a href="https://docs.oracle.com/en/java/javase/11/tools/jlink.html" id="kzmyhp_978" data-external="true" rel="noopener noreferrer" target="_blank">jlink tool</a>, which generates custom Java runtime images containing only the platform modules that are required for your app. You could already use jlink with Kotlin standard library artifacts, but you had to use separate artifacts to do so &ndash; the ones with the &quot;modular&quot; classifier &ndash; and the whole setup wasn't straightforward. <br> In Android, make sure you use the Android Gradle plugin version 3.2 or higher, which can correctly process jar files with module-info.</p></section><section class="chapter"><h3 id="deprecations" data-toc="deprecations">Deprecations</h3><section class="chapter"><h4 id="toshort-and-tobyte-of-double-and-float" data-toc="toshort-and-tobyte-of-double-and-float">toShort() and toByte() of Double and Float</h4><p id="kzmyhp_983">We've deprecated the functions <code class="code" id="kzmyhp_985">toShort()</code> and <code class="code" id="kzmyhp_986">toByte()</code> on <code class="code" id="kzmyhp_987">Double</code> and <code class="code" id="kzmyhp_988">Float</code> because they could lead to unexpected results because of the narrow value range and smaller variable size.</p><p id="kzmyhp_984">To convert floating-point numbers to <code class="code" id="kzmyhp_989">Byte</code> or <code class="code" id="kzmyhp_990">Short</code>, use the two-step conversion: first, convert them to <code class="code" id="kzmyhp_991">Int</code>, and then convert them again to the target type.</p></section><section class="chapter"><h4 id="contains-indexof-and-lastindexof-on-floating-point-arrays" data-toc="contains-indexof-and-lastindexof-on-floating-point-arrays">contains(), indexOf(), and lastIndexOf() on floating-point arrays</h4><p id="kzmyhp_992">We've deprecated the <code class="code" id="kzmyhp_993">contains()</code>, <code class="code" id="kzmyhp_994">indexOf()</code>, and <code class="code" id="kzmyhp_995">lastIndexOf()</code> extension functions of <code class="code" id="kzmyhp_996">FloatArray</code> and <code class="code" id="kzmyhp_997">DoubleArray</code> because they use the <a href="https://en.wikipedia.org/wiki/IEEE_754" id="kzmyhp_998" data-external="true" rel="noopener noreferrer" target="_blank">IEEE 754</a> standard equality, which contradicts the total order equality in some corner cases. See <a href="https://youtrack.jetbrains.com/issue/KT-28753" id="kzmyhp_999" data-external="true" rel="noopener noreferrer" target="_blank">this issue</a> for details.</p></section><section class="chapter"><h4 id="min-and-max-collection-functions" data-toc="min-and-max-collection-functions">min() and max() collection functions</h4><p id="kzmyhp_1000">We've deprecated the <code class="code" id="kzmyhp_1001">min()</code> and <code class="code" id="kzmyhp_1002">max()</code> collection functions in favor of <code class="code" id="kzmyhp_1003">minOrNull()</code> and <code class="code" id="kzmyhp_1004">maxOrNull()</code>, which more properly reflect their behavior &ndash; returning <code class="code" id="kzmyhp_1005">null</code> on empty collections. See <a href="https://youtrack.jetbrains.com/issue/KT-38854" id="kzmyhp_1006" data-external="true" rel="noopener noreferrer" target="_blank">this issue</a> for details.</p></section></section><section class="chapter"><h3 id="exclusion-of-the-deprecated-experimental-coroutines" data-toc="exclusion-of-the-deprecated-experimental-coroutines">Exclusion of the deprecated experimental coroutines</h3><p id="kzmyhp_1007">The <code class="code" id="kzmyhp_1008">kotlin.coroutines.experimental</code> API was deprecated in favor of kotlin.coroutines in 1.3.0. In 1.4.0, we're completing the deprecation cycle for <code class="code" id="kzmyhp_1009">kotlin.coroutines.experimental</code> by removing it from the standard library. For those who still use it on the JVM, we've provided a compatibility artifact <code class="code" id="kzmyhp_1010">kotlin-coroutines-experimental-compat.jar</code> with all the experimental coroutines APIs. We've published it to Maven, and we include it in the Kotlin distribution alongside the standard library.</p></section></section><section class="chapter"><h2 id="stable-json-serialization" data-toc="stable-json-serialization">Stable JSON serialization</h2><p id="kzmyhp_1011">With Kotlin 1.4.0, we are shipping the first stable version of <a href="https://github.com/Kotlin/kotlinx.serialization" id="kzmyhp_1014" data-external="true" rel="noopener noreferrer" target="_blank">kotlinx.serialization</a> - 1.0.0-RC. Now we are pleased to declare the JSON serialization API in <code class="code" id="kzmyhp_1015">kotlinx-serialization-core</code> (previously known as <code class="code" id="kzmyhp_1016">kotlinx-serialization-runtime</code>) stable. Libraries for other serialization formats remain experimental, along with some advanced parts of the core library.</p><p id="kzmyhp_1012">We have significantly reworked the API for JSON serialization to make it more consistent and easier to use. From now on, we'll continue developing the JSON serialization API in a backward-compatible manner. However, if you have used previous versions of it, you'll need to rewrite some of your code when migrating to 1.0.0-RC. To help you with this, we also offer the <span class="control" id="kzmyhp_1017"><a href="https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/serialization-guide.md" id="kzmyhp_1019" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin Serialization Guide</a></span> &ndash; the complete set of documentation for <code class="code" id="kzmyhp_1018">kotlinx.serialization</code>. It will guide you through the process of using the most important features and it can help you address any issues that you might face.</p><aside class="prompt" data-type="note" data-title="" id="kzmyhp_1013"><p id="kzmyhp_1020"><span class="control" id="kzmyhp_1021">Note</span>: <code class="code" id="kzmyhp_1022">kotlinx-serialization</code> 1.0.0-RC only works with Kotlin compiler 1.4. Earlier compiler versions are not compatible.</p></aside></section><section class="chapter"><h2 id="scripting-and-repl" data-toc="scripting-and-repl">Scripting and REPL</h2><p id="kzmyhp_1023">In 1.4.0, scripting in Kotlin benefits from a number of functional and performance improvements along with other updates. Here are some of the key changes:</p><ul class="list _bullet" id="kzmyhp_1024"><li class="list__item" id="kzmyhp_1030"><p id="kzmyhp_1034"><a href="#new-dependencies-resolution-api" id="kzmyhp_1035">New dependencies resolution API</a></p></li><li class="list__item" id="kzmyhp_1031"><p id="kzmyhp_1036"><a href="#new-repl-api" id="kzmyhp_1037">New REPL API</a></p></li><li class="list__item" id="kzmyhp_1032"><p id="kzmyhp_1038"><a href="#compiled-scripts-cache" id="kzmyhp_1039">Compiled scripts cache</a></p></li><li class="list__item" id="kzmyhp_1033"><p id="kzmyhp_1040"><a href="#artifacts-renaming" id="kzmyhp_1041">Artifacts renaming</a></p></li></ul><p id="kzmyhp_1025">To help you become more familiar with scripting in Kotlin, we've prepared a <a href="https://github.com/Kotlin/kotlin-script-examples" id="kzmyhp_1042" data-external="true" rel="noopener noreferrer" target="_blank">project with examples</a>. It contains examples of the standard scripts (<code class="code" id="kzmyhp_1043">*.main.kts</code>) and examples of uses of the Kotlin Scripting API and custom script definitions. Please give it a try and share your feedback using our <a href="https://youtrack.jetbrains.com/issues/KT" id="kzmyhp_1044" data-external="true" rel="noopener noreferrer" target="_blank">issue tracker</a>.</p><section class="chapter"><h3 id="new-dependencies-resolution-api" data-toc="new-dependencies-resolution-api">New dependencies resolution API</h3><p id="kzmyhp_1045">In 1.4.0, we've introduced a new API for resolving external dependencies (such as Maven artifacts), along with implementations for it. This API is published in the new artifacts <code class="code" id="kzmyhp_1046">kotlin-scripting-dependencies</code> and <code class="code" id="kzmyhp_1047">kotlin-scripting-dependencies-maven</code>. The previous dependency resolution functionality in <code class="code" id="kzmyhp_1048">kotlin-script-util</code> library is now deprecated.</p></section><section class="chapter"><h3 id="new-repl-api" data-toc="new-repl-api">New REPL API</h3><p id="kzmyhp_1049">The new experimental REPL API is now a part of the Kotlin Scripting API. There are also several implementations of it in the published artifacts, and some have advanced functionality, such as code completion. We use this API in the <a href="https://blog.jetbrains.com/kotlin/2020/05/kotlin-kernel-for-jupyter-notebook-v0-8/" id="kzmyhp_1050" data-external="true" rel="noopener noreferrer" target="_blank">Kotlin Jupyter kernel</a> and now you can try it in your own custom shells and REPLs.</p></section><section class="chapter"><h3 id="compiled-scripts-cache" data-toc="compiled-scripts-cache">Compiled scripts cache</h3><p id="kzmyhp_1051">The Kotlin Scripting API now provides the ability to implement a compiled scripts cache, significantly speeding up subsequent executions of unchanged scripts. Our default advanced script implementation <code class="code" id="kzmyhp_1052">kotlin-main-kts</code> already has its own cache.</p></section><section class="chapter"><h3 id="artifacts-renaming" data-toc="artifacts-renaming">Artifacts renaming</h3><p id="kzmyhp_1053">In order to avoid confusion about artifact names, we've renamed <code class="code" id="kzmyhp_1054">kotlin-scripting-jsr223-embeddable</code> and <code class="code" id="kzmyhp_1055">kotlin-scripting-jvm-host-embeddable</code> to just <code class="code" id="kzmyhp_1056">kotlin-scripting-jsr223</code> and <code class="code" id="kzmyhp_1057">kotlin-scripting-jvm-host</code>. These artifacts depend on the <code class="code" id="kzmyhp_1058">kotlin-compiler-embeddable</code> artifact, which shades the bundled third-party libraries to avoid usage conflicts. With this renaming, we're making the usage of <code class="code" id="kzmyhp_1059">kotlin-compiler-embeddable</code> (which is safer in general) the default for scripting artifacts. If, for some reason, you need artifacts that depend on the unshaded <code class="code" id="kzmyhp_1060">kotlin-compiler</code>, use the artifact versions with the <code class="code" id="kzmyhp_1061">-unshaded</code> suffix, such as <code class="code" id="kzmyhp_1062">kotlin-scripting-jsr223-unshaded</code>. Note that this renaming affects only the scripting artifacts that are supposed to be used directly; names of other artifacts remain unchanged.</p></section></section><section class="chapter"><h2 id="migrating-to-kotlin-1-4-0" data-toc="migrating-to-kotlin-1-4-0">Migrating to Kotlin 1.4.0</h2><p id="kzmyhp_1063">The Kotlin plugin's migration tools help you migrate your projects from earlier versions of Kotlin to 1.4.0.</p><p id="kzmyhp_1064">Just change the Kotlin version to <code class="code" id="kzmyhp_1070">1.4.0</code> and re-import your Gradle or Maven project. The IDE will then ask you about migration.</p><p id="kzmyhp_1065">If you agree, it will run migration code inspections that will check your code and suggest corrections for anything that doesn't work or that is not recommended in 1.4.0.</p><figure id="kzmyhp_1066"><img alt="Run migration" src="images/run-migration-wn.png" title="Run migration" width="300" height="60"></figure><p id="kzmyhp_1067">Code inspections have different <a href="https://www.jetbrains.com/help/idea/configuring-inspection-severities.html" id="kzmyhp_1071" data-external="true" rel="noopener noreferrer" target="_blank">severity levels</a>, to help you decide which suggestions to accept and which to ignore.</p><figure id="kzmyhp_1068"><img alt="Migration inspections" src="images/migration-inspection-wn.png" title="Migration inspections" width="1902" height="544"></figure><p id="kzmyhp_1069">Kotlin 1.4.0 is a <a href="kotlin-evolution-principles.html#language-and-tooling-releases" id="kzmyhp_1072">feature release</a> and therefore can bring incompatible changes to the language. Find the detailed list of such changes in the <span class="control" id="kzmyhp_1073"><a href="compatibility-guide-14.html" id="kzmyhp_1074">Compatibility Guide for Kotlin 1.4</a></span>.</p></section><div class="last-modified">26 June 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="whatsnew1420.html" class="navigation-links__prev">What's new in Kotlin 1.4.20</a><a href="whatsnew13.html" class="navigation-links__next">What's new in Kotlin 1.3</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>